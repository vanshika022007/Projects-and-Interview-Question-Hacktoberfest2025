{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/generateId.tsx"],"sourcesContent":["import { customAlphabet } from \"nanoid/non-secure\";\n\nexport const generateId = customAlphabet(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7,\n);\n"],"names":[],"mappings":";;;;AAAA,SAAS,sBAAsB;;AAExB,IAAM,yMAAa,iBAAA,EACxB,kEACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/utils/json/fix-json.ts"],"sourcesContent":["// LICENSE for this file only\n\n// MIT License\n\n// Copyright (c) 2025 AgentbaseAI Inc.\n// Copyright (c) 2023 Lars Grammel\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\ntype State =\n  | \"ROOT\"\n  | \"FINISH\"\n  | \"INSIDE_STRING\"\n  | \"INSIDE_STRING_ESCAPE\"\n  | \"INSIDE_LITERAL\"\n  | \"INSIDE_NUMBER\"\n  | \"INSIDE_OBJECT_START\"\n  | \"INSIDE_OBJECT_KEY\"\n  | \"INSIDE_OBJECT_AFTER_KEY\"\n  | \"INSIDE_OBJECT_BEFORE_VALUE\"\n  | \"INSIDE_OBJECT_AFTER_VALUE\"\n  | \"INSIDE_OBJECT_AFTER_COMMA\"\n  | \"INSIDE_ARRAY_START\"\n  | \"INSIDE_ARRAY_AFTER_VALUE\"\n  | \"INSIDE_ARRAY_AFTER_COMMA\";\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\n\n// Returns a tuple of [fixedJson, partialPath]\n// partialPath is an array of object/array keys that represent\n// the currently partial values. An object is considered partial\n// if through appending extra characters to the JSON string, its\n// value could change.\n\n// Example input: '{\"foo\":[{\"a\":f'\n// Example output: ['{\"foo\":[{\"a\":false}]}', ['foo', '0']]\n// Example input: '{\"foo\":'\n// Example output: ['{}', []]\n\nexport function fixJson(input: string): [string, string[]] {\n  const stack: State[] = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n  const path: string[] = [];\n  let currentKey: string | undefined;\n\n  function pushCurrentKeyToPath(): void {\n    if (currentKey !== undefined) {\n      path.push(JSON.parse('\"' + currentKey + '\"'));\n      currentKey = undefined;\n    }\n  }\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n\n          pushCurrentKeyToPath();\n          break;\n        }\n\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n\n          pushCurrentKeyToPath();\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n\n          pushCurrentKeyToPath();\n          break;\n        }\n\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n\n          pushCurrentKeyToPath();\n          break;\n        }\n\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n\n          pushCurrentKeyToPath();\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        currentKey = path.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        currentKey = (Number(currentKey) + 1).toString();\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        currentKey = path.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i]!;\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            currentKey = \"\";\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            currentKey = path.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            currentKey = \"\";\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            currentKey += char;\n            break;\n          }\n          default: {\n            currentKey += char;\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n\n            currentKey = path.pop();\n            break;\n          }\n\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            currentKey = path.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            currentKey = \"0\";\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n\n            currentKey = (Number(currentKey) + 1).toString();\n            break;\n          }\n\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            currentKey = path.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n\n        if (stack[stack.length - 1] === \"INSIDE_STRING\") {\n          lastValidIndex = i;\n        } else if (stack[stack.length - 1] === \"INSIDE_OBJECT_KEY\") {\n          currentKey += char;\n        }\n\n        break;\n      }\n\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n\n          case \",\": {\n            stack.pop();\n            currentKey = path.pop();\n\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case \"}\": {\n            stack.pop();\n            currentKey = path.pop();\n\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case \"]\": {\n            stack.pop();\n            currentKey = path.pop();\n\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            currentKey = path.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !\"false\".startsWith(partialLiteral) &&\n          !\"true\".startsWith(partialLiteral) &&\n          !\"null\".startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return [result, path];\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 444, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/utils/json/parse-partial-json-object.ts"],"sourcesContent":["import sjson from \"secure-json-parse\";\nimport { fixJson } from \"./fix-json\";\nimport { ReadonlyJSONObject } from \"./json-value\";\n\nconst PARTIAL_JSON_OBJECT_META_SYMBOL = Symbol(\n  \"aui.parse-partial-json-object.meta\",\n);\n\ntype FieldState = \"complete\" | \"partial\";\n\ntype PartialJsonObjectMeta = {\n  state: \"complete\" | \"partial\";\n  partialPath: string[];\n};\n\nexport const getPartialJsonObjectMeta = (\n  obj: Record<symbol, unknown>,\n): PartialJsonObjectMeta | undefined => {\n  return obj?.[PARTIAL_JSON_OBJECT_META_SYMBOL] as PartialJsonObjectMeta;\n};\n\nexport const parsePartialJsonObject = (\n  json: string,\n):\n  | (ReadonlyJSONObject & {\n      [PARTIAL_JSON_OBJECT_META_SYMBOL]: PartialJsonObjectMeta;\n    })\n  | undefined => {\n  if (json.length === 0)\n    return {\n      [PARTIAL_JSON_OBJECT_META_SYMBOL]: { state: \"partial\", partialPath: [] },\n    };\n\n  try {\n    const res = sjson.parse(json);\n    if (typeof res !== \"object\" || res === null)\n      throw new Error(\"argsText is expected to be an object\");\n\n    res[PARTIAL_JSON_OBJECT_META_SYMBOL] = {\n      state: \"complete\",\n      partialPath: [],\n    };\n    return res;\n  } catch {\n    try {\n      const [fixedJson, partialPath] = fixJson(json);\n      const res = sjson.parse(fixedJson);\n      if (typeof res !== \"object\" || res === null)\n        throw new Error(\"argsText is expected to be an object\");\n\n      res[PARTIAL_JSON_OBJECT_META_SYMBOL] = {\n        state: \"partial\",\n        partialPath,\n      };\n      return res;\n    } catch {\n      return undefined;\n    }\n  }\n};\n\nconst getFieldState = (\n  parent: unknown,\n  parentMeta: PartialJsonObjectMeta,\n  fieldPath: string[],\n): FieldState => {\n  if (typeof parent !== \"object\" || parent === null) return parentMeta.state;\n\n  // 1) parent is complete: return \"complete\"\n  if (parentMeta.state === \"complete\") return \"complete\";\n\n  // 2) we finished traversing: return parent state\n  if (fieldPath.length === 0) return parentMeta.state;\n\n  const [field, ...restPath] = fieldPath as [string, ...string[]];\n\n  // 3) field doesn't yet exist in parent: return \"partial\"\n  if (!Object.prototype.hasOwnProperty.call(parent, field)) return \"partial\";\n\n  const [partialField, ...restPartialPath] = parentMeta.partialPath;\n\n  // 4) field exists but is not partial: return \"complete\"\n  if (field !== partialField) return \"complete\";\n\n  // 5) field exists and is partial: return child state\n  const child = (parent as Record<string, unknown>)[field];\n  const childMeta: PartialJsonObjectMeta = {\n    state: \"partial\",\n    partialPath: restPartialPath,\n  };\n\n  return getFieldState(child, childMeta, restPath);\n};\n\nexport const getPartialJsonObjectFieldState = (\n  obj: Record<string, unknown>,\n  fieldPath: (string | number)[],\n): FieldState => {\n  const meta = getPartialJsonObjectMeta(obj);\n  if (!meta) throw new Error(\"unable to determine object state\");\n\n  return getFieldState(obj, meta, fieldPath.map(String));\n};\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,WAAW;AAClB,SAAS,eAAe;;;AAGxB,IAAM,kCAAkC,OACtC;AAUK,IAAM,2BAA2B,CACtC,QACsC;IACtC,OAAO,KAAA,CAAM,+BAA+B,CAAA;AAC9C;AAEO,IAAM,yBAAyB,CACpC,SAKe;IACf,IAAI,KAAK,MAAA,KAAW,GAClB,OAAO;QACL,CAAC,+BAA+B,CAAA,EAAG;YAAE,OAAO;YAAW,aAAa,CAAC,CAAA;QAAE;IACzE;IAEF,IAAI;QACF,MAAM,MAAM,kMAAA,CAAM,KAAA,CAAM,IAAI;QAC5B,IAAI,OAAO,QAAQ,YAAY,QAAQ,MACrC,MAAM,IAAI,MAAM,sCAAsC;QAExD,GAAA,CAAI,+BAA+B,CAAA,GAAI;YACrC,OAAO;YACP,aAAa,CAAC,CAAA;QAChB;QACA,OAAO;IACT,EAAA,OAAQ;QACN,IAAI;YACF,MAAM,CAAC,WAAW,WAAW,CAAA,mLAAI,UAAA,EAAQ,IAAI;YAC7C,MAAM,8LAAM,UAAA,CAAM,KAAA,CAAM,SAAS;YACjC,IAAI,OAAO,QAAQ,YAAY,QAAQ,MACrC,MAAM,IAAI,MAAM,sCAAsC;YAExD,GAAA,CAAI,+BAA+B,CAAA,GAAI;gBACrC,OAAO;gBACP;YACF;YACA,OAAO;QACT,EAAA,OAAQ;YACN,OAAO,KAAA;QACT;IACF;AACF;AAEA,IAAM,gBAAgB,CACpB,QACA,YACA,cACe;IACf,IAAI,OAAO,WAAW,YAAY,WAAW,KAAM,CAAA,OAAO,WAAW,KAAA;IAGrE,IAAI,WAAW,KAAA,KAAU,WAAY,CAAA,OAAO;IAG5C,IAAI,UAAU,MAAA,KAAW,EAAG,CAAA,OAAO,WAAW,KAAA;IAE9C,MAAM,CAAC,OAAO,GAAG,QAAQ,CAAA,GAAI;IAG7B,IAAI,CAAC,OAAO,SAAA,CAAU,cAAA,CAAe,IAAA,CAAK,QAAQ,KAAK,EAAG,CAAA,OAAO;IAEjE,MAAM,CAAC,cAAc,GAAG,eAAe,CAAA,GAAI,WAAW,WAAA;IAGtD,IAAI,UAAU,aAAc,CAAA,OAAO;IAGnC,MAAM,QAAS,MAAA,CAAmC,KAAK,CAAA;IACvD,MAAM,YAAmC;QACvC,OAAO;QACP,aAAa;IACf;IAEA,OAAO,cAAc,OAAO,WAAW,QAAQ;AACjD;AAEO,IAAM,iCAAiC,CAC5C,KACA,cACe;IACf,MAAM,OAAO,yBAAyB,GAAG;IACzC,IAAI,CAAC,KAAM,CAAA,MAAM,IAAI,MAAM,kCAAkC;IAE7D,OAAO,cAAc,KAAK,MAAM,UAAU,GAAA,CAAI,MAAM,CAAC;AACvD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 516, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/object/ObjectStreamAccumulator.ts"],"sourcesContent":["import { ReadonlyJSONValue, ReadonlyJSONObject } from \"../../utils\";\nimport { ObjectStreamOperation } from \"./types\";\n\nexport class ObjectStreamAccumulator {\n  private _state: ReadonlyJSONValue;\n\n  constructor(initialValue: ReadonlyJSONValue = null) {\n    this._state = initialValue;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  append(ops: readonly ObjectStreamOperation[]) {\n    this._state = ops.reduce(\n      (state, op) => ObjectStreamAccumulator.apply(state, op),\n      this._state,\n    );\n  }\n\n  private static apply(state: ReadonlyJSONValue, op: ObjectStreamOperation) {\n    const type = op.type;\n    switch (type) {\n      case \"set\":\n        return ObjectStreamAccumulator.updatePath(\n          state,\n          op.path,\n          () => op.value,\n        );\n      case \"append-text\":\n        return ObjectStreamAccumulator.updatePath(state, op.path, (current) => {\n          if (typeof current !== \"string\")\n            throw new Error(`Expected string at path [${op.path.join(\", \")}]`);\n          return current + op.value;\n        });\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Invalid operation type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  private static updatePath(\n    state: ReadonlyJSONValue | undefined,\n    path: readonly string[],\n    updater: (current: ReadonlyJSONValue | undefined) => ReadonlyJSONValue,\n  ): ReadonlyJSONValue {\n    if (path.length === 0) return updater(state);\n\n    // Initialize state as empty object if it's null and we're trying to set a property\n    state ??= {};\n\n    if (typeof state !== \"object\") {\n      throw new Error(`Invalid path: [${path.join(\", \")}]`);\n    }\n\n    const [key, ...rest] = path as [string, ...(readonly string[])];\n    if (Array.isArray(state)) {\n      const idx = Number(key);\n      if (isNaN(idx))\n        throw new Error(`Expected array index at [${path.join(\", \")}]`);\n      if (idx > state.length || idx < 0)\n        throw new Error(`Insert array index out of bounds`);\n\n      const nextState = [...state];\n      nextState[idx] = this.updatePath(nextState[idx], rest, updater);\n\n      return nextState;\n    }\n\n    const nextState = { ...(state as ReadonlyJSONObject) };\n    nextState[key] = this.updatePath(nextState[key], rest, updater);\n\n    return nextState;\n  }\n}\n"],"names":["nextState"],"mappings":";;;;AAGO,IAAM,0BAAN,MAAM,yBAAwB;IAC3B,OAAA;IAER,YAAY,eAAkC,IAAA,CAAM;QAClD,IAAA,CAAK,MAAA,GAAS;IAChB;IAEA,IAAI,QAAQ;QACV,OAAO,IAAA,CAAK,MAAA;IACd;IAEA,OAAO,GAAA,EAAuC;QAC5C,IAAA,CAAK,MAAA,GAAS,IAAI,MAAA,CAChB,CAAC,OAAO,KAAO,yBAAwB,KAAA,CAAM,OAAO,EAAE,GACtD,IAAA,CAAK,MAAA;IAET;IAEA,OAAe,MAAM,KAAA,EAA0B,EAAA,EAA2B;QACxE,MAAM,OAAO,GAAG,IAAA;QAChB,OAAQ,MAAM;YACZ,KAAK;gBACH,OAAO,yBAAwB,UAAA,CAC7B,OACA,GAAG,IAAA,EACH,IAAM,GAAG,KAAA;YAEb,KAAK;gBACH,OAAO,yBAAwB,UAAA,CAAW,OAAO,GAAG,IAAA,EAAM,CAAC,YAAY;oBACrE,IAAI,OAAO,YAAY,UACrB,MAAM,IAAI,MAAM,CAAA,yBAAA,EAA4B,GAAG,IAAA,CAAK,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAG;oBACnE,OAAO,UAAU,GAAG,KAAA;gBACtB,CAAC;YAEH;gBAAS;oBACP,MAAM,mBAA0B;oBAChC,MAAM,IAAI,MAAM,CAAA,wBAAA,EAA2B,gBAAgB,EAAE;gBAC/D;QACF;IACF;IAEA,OAAe,WACb,KAAA,EACA,IAAA,EACA,OAAA,EACmB;QACnB,IAAI,KAAK,MAAA,KAAW,EAAG,CAAA,OAAO,QAAQ,KAAK;QAG3C,UAAU,CAAC;QAEX,IAAI,OAAO,UAAU,UAAU;YAC7B,MAAM,IAAI,MAAM,CAAA,eAAA,EAAkB,KAAK,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAG;QACtD;QAEA,MAAM,CAAC,KAAK,GAAG,IAAI,CAAA,GAAI;QACvB,IAAI,MAAM,OAAA,CAAQ,KAAK,GAAG;YACxB,MAAM,MAAM,OAAO,GAAG;YACtB,IAAI,MAAM,GAAG,GACX,MAAM,IAAI,MAAM,CAAA,yBAAA,EAA4B,KAAK,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAG;YAChE,IAAI,MAAM,MAAM,MAAA,IAAU,MAAM,GAC9B,MAAM,IAAI,MAAM,CAAA,gCAAA,CAAkC;YAEpD,MAAMA,aAAY,CAAC;mBAAG,KAAK;aAAA;YAC3BA,UAAAA,CAAU,GAAG,CAAA,GAAI,IAAA,CAAK,UAAA,CAAWA,UAAAA,CAAU,GAAG,CAAA,EAAG,MAAM,OAAO;YAE9D,OAAOA;QACT;QAEA,MAAM,YAAY;YAAE,GAAI,KAAA;QAA6B;QACrD,SAAA,CAAU,GAAG,CAAA,GAAI,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,GAAG,CAAA,EAAG,MAAM,OAAO;QAE9D,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 580, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/accumulators/assistant-message-accumulator.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { generateId } from \"../utils/generateId\";\nimport { parsePartialJsonObject } from \"../../utils/json/parse-partial-json-object\";\nimport {\n  AssistantMessage,\n  AssistantMessageStatus,\n  TextPart,\n  ToolCallPart,\n  SourcePart,\n  AssistantMessagePart,\n  ReasoningPart,\n  FilePart,\n} from \"../utils/types\";\nimport { ObjectStreamAccumulator } from \"../object/ObjectStreamAccumulator\";\n\nconst createInitialMessage = (): AssistantMessage => ({\n  role: \"assistant\",\n  status: { type: \"running\" },\n  parts: [],\n  get content() {\n    return this.parts;\n  },\n  metadata: {\n    unstable_state: null,\n    unstable_data: [],\n    unstable_annotations: [],\n    steps: [],\n    custom: {},\n  },\n});\n\nconst updatePartForPath = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk,\n  updater: (part: AssistantMessagePart) => AssistantMessagePart,\n): AssistantMessage => {\n  if (message.parts.length === 0) {\n    throw new Error(\"No parts available to update.\");\n  }\n\n  if (chunk.path.length !== 1)\n    throw new Error(\"Nested paths are not supported yet.\");\n\n  const partIndex = chunk.path[0]!;\n  const updatedPart = updater(message.parts[partIndex]!);\n  return {\n    ...message,\n    parts: [\n      ...message.parts.slice(0, partIndex),\n      updatedPart,\n      ...message.parts.slice(partIndex + 1),\n    ],\n    get content() {\n      return this.parts;\n    },\n  };\n};\n\nconst handlePartStart = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { readonly type: \"part-start\" },\n): AssistantMessage => {\n  const partInit = chunk.part;\n  if (partInit.type === \"text\" || partInit.type === \"reasoning\") {\n    const newTextPart: TextPart | ReasoningPart = {\n      type: partInit.type,\n      text: \"\",\n      status: { type: \"running\" },\n    };\n    return {\n      ...message,\n      parts: [...message.parts, newTextPart],\n      get content() {\n        return this.parts;\n      },\n    };\n  } else if (partInit.type === \"tool-call\") {\n    const newToolCallPart: ToolCallPart = {\n      type: \"tool-call\",\n      state: \"partial-call\",\n      status: { type: \"running\", isArgsComplete: false },\n      toolCallId: partInit.toolCallId,\n      toolName: partInit.toolName,\n      argsText: \"\",\n      args: {},\n    };\n    return {\n      ...message,\n      parts: [...message.parts, newToolCallPart],\n      get content() {\n        return this.parts;\n      },\n    };\n  } else if (partInit.type === \"source\") {\n    const newSourcePart: SourcePart = {\n      type: \"source\",\n      sourceType: partInit.sourceType,\n      id: partInit.id,\n      url: partInit.url,\n      ...(partInit.title ? { title: partInit.title } : undefined),\n    };\n    return {\n      ...message,\n      parts: [...message.parts, newSourcePart],\n      get content() {\n        return this.parts;\n      },\n    };\n  } else if (partInit.type === \"file\") {\n    const newFilePart: FilePart = {\n      type: \"file\",\n      mimeType: partInit.mimeType,\n      data: partInit.data,\n    };\n    return {\n      ...message,\n      parts: [...message.parts, newFilePart],\n      get content() {\n        return this.parts;\n      },\n    };\n  } else {\n    throw new Error(`Unsupported part type: ${partInit.type}`);\n  }\n};\n\nconst handleToolCallArgsTextFinish = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & {\n    readonly type: \"tool-call-args-text-finish\";\n  },\n): AssistantMessage => {\n  return updatePartForPath(message, chunk, (part) => {\n    if (part.type !== \"tool-call\") {\n      throw new Error(\"Last is not a tool call\");\n    }\n\n    // TODO this should never be hit; this happens if args-text-finish is emitted after resutl\n    if (part.state !== \"partial-call\") return part;\n    // throw new Error(\"Last is not a partial call\");\n\n    return {\n      ...part,\n      state: \"call\",\n    };\n  });\n};\n\nconst handlePartFinish = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { readonly type: \"part-finish\" },\n): AssistantMessage => {\n  return updatePartForPath(message, chunk, (part) => ({\n    ...part,\n    status: { type: \"complete\", reason: \"unknown\" },\n  }));\n};\n\nconst handleTextDelta = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"text-delta\" },\n): AssistantMessage => {\n  return updatePartForPath(message, chunk, (part) => {\n    if (part.type === \"text\" || part.type === \"reasoning\") {\n      return { ...part, text: part.text + chunk.textDelta };\n    } else if (part.type === \"tool-call\") {\n      const newArgsText = part.argsText + chunk.textDelta;\n\n      // Fall back to existing args if parsing fails\n      const newArgs = parsePartialJsonObject(newArgsText) ?? part.args;\n\n      return { ...part, argsText: newArgsText, args: newArgs };\n    } else {\n      throw new Error(\n        \"text-delta received but part is neither text nor tool-call\",\n      );\n    }\n  });\n};\n\nconst handleResult = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"result\" },\n): AssistantMessage => {\n  return updatePartForPath(message, chunk, (part) => {\n    if (part.type === \"tool-call\") {\n      return {\n        ...part,\n        state: \"result\",\n        ...(chunk.artifact !== undefined ? { artifact: chunk.artifact } : {}),\n        result: chunk.result,\n        isError: chunk.isError ?? false,\n        status: { type: \"complete\", reason: \"stop\" },\n      };\n    } else {\n      throw new Error(\"Result chunk received but part is not a tool-call\");\n    }\n  });\n};\n\nconst handleMessageFinish = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"message-finish\" },\n): AssistantMessage => {\n  const newStatus = getStatus(chunk);\n  return { ...message, status: newStatus };\n};\n\nconst getStatus = (\n  chunk:\n    | (AssistantStreamChunk & { type: \"message-finish\" })\n    | (AssistantStreamChunk & { type: \"step-finish\" }),\n): AssistantMessageStatus => {\n  if (chunk.finishReason === \"tool-calls\") {\n    return {\n      type: \"requires-action\",\n      reason: \"tool-calls\",\n    };\n  } else if (\n    chunk.finishReason === \"stop\" ||\n    chunk.finishReason === \"unknown\"\n  ) {\n    return {\n      type: \"complete\",\n      reason: chunk.finishReason,\n    };\n  } else {\n    return {\n      type: \"incomplete\",\n      reason: chunk.finishReason,\n    };\n  }\n};\n\nconst handleAnnotations = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"annotations\" },\n): AssistantMessage => {\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      unstable_annotations: [\n        ...message.metadata.unstable_annotations,\n        ...chunk.annotations,\n      ],\n    },\n  };\n};\n\nconst handleData = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"data\" },\n): AssistantMessage => {\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      unstable_data: [...message.metadata.unstable_data, ...chunk.data],\n    },\n  };\n};\n\nconst handleStepStart = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"step-start\" },\n): AssistantMessage => {\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      steps: [\n        ...message.metadata.steps,\n        { state: \"started\", messageId: chunk.messageId },\n      ],\n    },\n  };\n};\n\nconst handleStepFinish = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"step-finish\" },\n): AssistantMessage => {\n  const steps = message.metadata.steps.slice();\n  const lastIndex = steps.length - 1;\n\n  // Check if the previous step is a step-start (has state \"started\")\n  if (steps.length > 0 && steps[lastIndex]?.state === \"started\") {\n    steps[lastIndex] = {\n      ...steps[lastIndex],\n      state: \"finished\",\n      finishReason: chunk.finishReason,\n      usage: chunk.usage,\n      isContinued: chunk.isContinued,\n    };\n  } else {\n    // If no previous step-start exists, append a finished step\n    steps.push({\n      state: \"finished\",\n      messageId: generateId(),\n      finishReason: chunk.finishReason,\n      usage: chunk.usage,\n      isContinued: chunk.isContinued,\n    });\n  }\n\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      steps,\n    },\n  };\n};\n\nconst handleErrorChunk = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"error\" },\n): AssistantMessage => {\n  return {\n    ...message,\n    status: { type: \"incomplete\", reason: \"error\", error: chunk.error },\n  };\n};\n\nconst handleUpdateState = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"update-state\" },\n): AssistantMessage => {\n  const acc = new ObjectStreamAccumulator(message.metadata.unstable_state);\n  acc.append(chunk.operations);\n\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      unstable_state: acc.state,\n    },\n  };\n};\n\nexport class AssistantMessageAccumulator extends TransformStream<\n  AssistantStreamChunk,\n  AssistantMessage\n> {\n  constructor({\n    initialMessage,\n  }: {\n    initialMessage?: AssistantMessage;\n  } = {}) {\n    let message = initialMessage ?? createInitialMessage();\n    super({\n      transform(chunk, controller) {\n        const type = chunk.type;\n        switch (type) {\n          case \"part-start\":\n            message = handlePartStart(message, chunk);\n            break;\n\n          case \"tool-call-args-text-finish\":\n            message = handleToolCallArgsTextFinish(message, chunk);\n            break;\n\n          case \"part-finish\":\n            message = handlePartFinish(message, chunk);\n            break;\n\n          case \"text-delta\":\n            message = handleTextDelta(message, chunk);\n            break;\n          case \"result\":\n            message = handleResult(message, chunk);\n            break;\n          case \"message-finish\":\n            message = handleMessageFinish(message, chunk);\n            break;\n          case \"annotations\":\n            message = handleAnnotations(message, chunk);\n            break;\n          case \"data\":\n            message = handleData(message, chunk);\n            break;\n          case \"step-start\":\n            message = handleStepStart(message, chunk);\n            break;\n          case \"step-finish\":\n            message = handleStepFinish(message, chunk);\n            break;\n          case \"error\":\n            message = handleErrorChunk(message, chunk);\n            break;\n          case \"update-state\":\n            message = handleUpdateState(message, chunk);\n            break;\n          default: {\n            const unhandledType: never = type;\n            throw new Error(`Unsupported chunk type: ${unhandledType}`);\n          }\n        }\n        controller.enqueue(message);\n      },\n      flush(controller) {\n        if (message.status?.type === \"running\") {\n          // TODO this test isn't sound\n          const requiresAction = message.parts?.at(-1)?.type === \"tool-call\";\n          message = handleMessageFinish(message, {\n            type: \"message-finish\",\n            path: [],\n            finishReason: requiresAction ? \"tool-calls\" : \"unknown\",\n            usage: {\n              promptTokens: 0,\n              completionTokens: 0,\n            },\n          });\n          controller.enqueue(message);\n        }\n      },\n    });\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 961, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/AssistantStream.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"./AssistantStreamChunk\";\n\nexport type AssistantStream = ReadableStream<AssistantStreamChunk>;\n\nexport type AssistantStreamEncoder = ReadableWritablePair<\n  Uint8Array,\n  AssistantStreamChunk\n> & {\n  headers?: Headers;\n};\n\nexport const AssistantStream = {\n  toResponse(stream: AssistantStream, transformer: AssistantStreamEncoder) {\n    return new Response(AssistantStream.toByteStream(stream, transformer), {\n      headers: transformer.headers ?? {},\n    });\n  },\n\n  fromResponse(\n    response: Response,\n    transformer: ReadableWritablePair<AssistantStreamChunk, Uint8Array>,\n  ) {\n    return AssistantStream.fromByteStream(response.body!, transformer);\n  },\n\n  toByteStream(\n    stream: AssistantStream,\n    transformer: ReadableWritablePair<Uint8Array, AssistantStreamChunk>,\n  ) {\n    return stream.pipeThrough(transformer);\n  },\n\n  fromByteStream(\n    readable: ReadableStream<Uint8Array>,\n    transformer: ReadableWritablePair<AssistantStreamChunk, Uint8Array>,\n  ) {\n    return readable.pipeThrough(transformer);\n  },\n};\n"],"names":[],"mappings":";;;;AAWO,IAAM,kBAAkB;IAC7B,YAAW,MAAA,EAAyB,WAAA,EAAqC;QACvE,OAAO,IAAI,SAAS,gBAAgB,YAAA,CAAa,QAAQ,WAAW,GAAG;YACrE,SAAS,YAAY,OAAA,IAAW,CAAC;QACnC,CAAC;IACH;IAEA,cACE,QAAA,EACA,WAAA,EACA;QACA,OAAO,gBAAgB,cAAA,CAAe,SAAS,IAAA,EAAO,WAAW;IACnE;IAEA,cACE,MAAA,EACA,WAAA,EACA;QACA,OAAO,OAAO,WAAA,CAAY,WAAW;IACvC;IAEA,gBACE,QAAA,EACA,WAAA,EACA;QACA,OAAO,SAAS,WAAA,CAAY,WAAW;IACzC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/utils/promiseWithResolvers.ts"],"sourcesContent":["export const promiseWithResolvers = function <T>() {\n  let resolve: ((value: T | PromiseLike<T>) => void) | undefined;\n  let reject: ((reason?: unknown) => void) | undefined;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  if (!resolve || !reject) throw new Error(\"Failed to create promise\");\n  return { promise, resolve, reject };\n};\n"],"names":[],"mappings":";;;;AAAO,IAAM,uBAAuB,WAAe;IACjD,IAAI;IACJ,IAAI;IACJ,MAAM,UAAU,IAAI,QAAW,CAAC,KAAK,QAAQ;QAC3C,UAAU;QACV,SAAS;IACX,CAAC;IACD,IAAI,CAAC,WAAW,CAAC,OAAQ,CAAA,MAAM,IAAI,MAAM,0BAA0B;IACnE,OAAO;QAAE;QAAS;QAAS;IAAO;AACpC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1015, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/stream/merge.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { promiseWithResolvers } from \"../../../utils/promiseWithResolvers\";\n\ntype MergeStreamItem = {\n  reader: ReadableStreamDefaultReader<AssistantStreamChunk>;\n  promise?: Promise<unknown> | undefined;\n};\n\nexport const createMergeStream = () => {\n  const list: MergeStreamItem[] = [];\n  let sealed = false;\n  let controller: ReadableStreamDefaultController<AssistantStreamChunk>;\n  let currentPull: ReturnType<typeof promiseWithResolvers<void>> | undefined;\n\n  const handlePull = (item: MergeStreamItem) => {\n    if (!item.promise) {\n      // TODO for most streams, we can directly pipeTo to avoid the microTask queue\n      // add an option to eagerly pipe the stream to the merge stream\n      // ideally, using assitant-stream w sync run method + piping to a sync WritableStream runs in the same microtask\n      // this is useful because we often use AssistantStreams internally as a serialization utility, e. g. AssistantTransformStream\n      // idea: avoid reader.read() by instead using a WritableStream & if (!hasPendingPull) await waitForPull()?\n      item.promise = item.reader\n        .read()\n        .then(({ done, value }) => {\n          item.promise = undefined;\n          if (done) {\n            list.splice(list.indexOf(item), 1);\n            if (sealed && list.length === 0) {\n              controller.close();\n            }\n          } else {\n            controller.enqueue(value);\n          }\n\n          currentPull?.resolve();\n          currentPull = undefined;\n        })\n        .catch((e) => {\n          console.error(e);\n\n          list.forEach((item) => {\n            item.reader.cancel();\n          });\n          list.length = 0;\n\n          controller.error(e);\n\n          currentPull?.reject(e);\n          currentPull = undefined;\n        });\n    }\n  };\n\n  const readable = new ReadableStream<AssistantStreamChunk>({\n    start(c) {\n      controller = c;\n    },\n    pull() {\n      currentPull = promiseWithResolvers();\n      list.forEach((item) => {\n        handlePull(item);\n      });\n\n      return currentPull.promise;\n    },\n    cancel() {\n      list.forEach((item) => {\n        item.reader.cancel();\n      });\n      list.length = 0;\n    },\n  });\n\n  return {\n    readable,\n    isSealed() {\n      return sealed;\n    },\n    seal() {\n      sealed = true;\n      if (list.length === 0) controller.close();\n    },\n    addStream(stream: ReadableStream<AssistantStreamChunk>) {\n      if (sealed)\n        throw new Error(\n          \"Cannot add streams after the run callback has settled.\",\n        );\n\n      const item = { reader: stream.getReader() };\n      list.push(item);\n      handlePull(item);\n    },\n    enqueue(chunk: AssistantStreamChunk) {\n      this.addStream(\n        new ReadableStream({\n          start(c) {\n            c.enqueue(chunk);\n            c.close();\n          },\n        }),\n      );\n    },\n  };\n};\n\n// TODO\n// export class SpanContainerMerger {\n//   public get isSealed() {\n//     return this.mergeStream.isSealed();\n//   }\n\n//   public get readable() {\n//     return this.mergeStream.readable;\n//   }\n\n//   private subAllocator = new Counter();\n//   private mergeStream = createMergeStream();\n\n//   constructor() {\n//     // id 0 is auto allocated\n//     this.subAllocator.up();\n//   }\n\n//   add(stream: ReadableStream<AssistantStreamChunk>) {\n//     this.mergeStream.addStream(\n//       stream.pipeThrough(new SpanParentEncoder(this.subAllocator)),\n//     );\n//   }\n\n//   enqueue(chunk: AssistantStreamChunk & { parentId: 0 }) {\n//     this.mergeStream.addStream(\n//       new ReadableStream({\n//         start(c) {\n//           c.enqueue(chunk);\n//           c.close();\n//         },\n//       }),\n//     );\n//   }\n\n//   seal() {\n//     this.mergeStream.seal();\n//   }\n// }\n\n// export class SpanContainerSplitter {\n//   public writable;\n\n//   private isSealed = false;\n//   private writers = new Map<\n//     number,\n//     WritableStreamDefaultWriter<AssistantStreamChunk>\n//   >();\n\n//   private closeTasks: Promise<void>[] = [];\n\n//   private allocator = new Counter();\n//   private subAllocator = new Counter();\n\n//   constructor() {\n//     // id 0 is auto-allocated\n//     this.allocator.up();\n\n//     this.writable = new WritableStream({\n//       write: (chunk) => {\n//         const { type, parentId } = chunk;\n\n//         const writer = this.writers.get(parentId);\n//         if (writer === undefined) throw new Error(\"Parent id not found\");\n\n//         writer.write(chunk);\n\n//         if (type === \"span\") {\n//           // allocate a new span id\n//           this.writers.set(this.allocator.up(), writer);\n//         }\n//         if (type === \"finish\") {\n//           this.writers.delete(parentId);\n//           writer.close();\n\n//           if (this.writers.size === 0) {\n//             const closeTask = this.writable.close();\n//             this.closeTasks.push(closeTask);\n//             closeTask.then(() => {\n//               this.closeTasks.splice(this.closeTasks.indexOf(closeTask), 1);\n//             });\n//           }\n//         }\n//       },\n//       close: async () => {\n//         if (this.writers.size > 0) throw new Error(\"Not all writers closed\");\n\n//         // await and throw on any errors\n//         await Promise.all(this.closeTasks);\n//       },\n//     });\n//   }\n\n//   add(stream: WritableStream<AssistantStreamChunk>) {\n//     if (this.isSealed) throw new Error(\"Cannot add streams after sealing\");\n\n//     const decoder = new SpanParentDecoder(this.subAllocator);\n//     decoder.readable.pipeTo(stream);\n\n//     this.writers.set(this.allocator.up(), decoder.writable.getWriter());\n//   }\n\n//   seal() {\n//     this.isSealed = true;\n//     if (this.writers.size === 0) this.writable.close();\n//   }\n// }\n"],"names":["item"],"mappings":";;;;AACA,SAAS,4BAA4B;;AAO9B,IAAM,oBAAoB,MAAM;IACrC,MAAM,OAA0B,CAAC,CAAA;IACjC,IAAI,SAAS;IACb,IAAI;IACJ,IAAI;IAEJ,MAAM,aAAa,CAAC,SAA0B;QAC5C,IAAI,CAAC,KAAK,OAAA,EAAS;YAMjB,KAAK,OAAA,GAAU,KAAK,MAAA,CACjB,IAAA,CAAK,EACL,IAAA,CAAK,CAAC,EAAE,IAAA,EAAM,KAAA,CAAM,CAAA,KAAM;gBACzB,KAAK,OAAA,GAAU,KAAA;gBACf,IAAI,MAAM;oBACR,KAAK,MAAA,CAAO,KAAK,OAAA,CAAQ,IAAI,GAAG,CAAC;oBACjC,IAAI,UAAU,KAAK,MAAA,KAAW,GAAG;wBAC/B,WAAW,KAAA,CAAM;oBACnB;gBACF,OAAO;oBACL,WAAW,OAAA,CAAQ,KAAK;gBAC1B;gBAEA,aAAa,QAAQ;gBACrB,cAAc,KAAA;YAChB,CAAC,EACA,KAAA,CAAM,CAAC,MAAM;gBACZ,QAAQ,KAAA,CAAM,CAAC;gBAEf,KAAK,OAAA,CAAQ,CAACA,UAAS;oBACrBA,MAAK,MAAA,CAAO,MAAA,CAAO;gBACrB,CAAC;gBACD,KAAK,MAAA,GAAS;gBAEd,WAAW,KAAA,CAAM,CAAC;gBAElB,aAAa,OAAO,CAAC;gBACrB,cAAc,KAAA;YAChB,CAAC;QACL;IACF;IAEA,MAAM,WAAW,IAAI,eAAqC;QACxD,OAAM,CAAA,EAAG;YACP,aAAa;QACf;QACA,OAAO;YACL,cAAc,wMAAA,CAAqB;YACnC,KAAK,OAAA,CAAQ,CAAC,SAAS;gBACrB,WAAW,IAAI;YACjB,CAAC;YAED,OAAO,YAAY,OAAA;QACrB;QACA,SAAS;YACP,KAAK,OAAA,CAAQ,CAAC,SAAS;gBACrB,KAAK,MAAA,CAAO,MAAA,CAAO;YACrB,CAAC;YACD,KAAK,MAAA,GAAS;QAChB;IACF,CAAC;IAED,OAAO;QACL;QACA,WAAW;YACT,OAAO;QACT;QACA,OAAO;YACL,SAAS;YACT,IAAI,KAAK,MAAA,KAAW,EAAG,CAAA,WAAW,KAAA,CAAM;QAC1C;QACA,WAAU,MAAA,EAA8C;YACtD,IAAI,QACF,MAAM,IAAI,MACR;YAGJ,MAAM,OAAO;gBAAE,QAAQ,OAAO,SAAA,CAAU;YAAE;YAC1C,KAAK,IAAA,CAAK,IAAI;YACd,WAAW,IAAI;QACjB;QACA,SAAQ,KAAA,EAA6B;YACnC,IAAA,CAAK,SAAA,CACH,IAAI,eAAe;gBACjB,OAAM,CAAA,EAAG;oBACP,EAAE,OAAA,CAAQ,KAAK;oBACf,EAAE,KAAA,CAAM;gBACV;YACF,CAAC;QAEL;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1105, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/modules/text.ts"],"sourcesContent":["import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { UnderlyingReadable } from \"../utils/stream/UnderlyingReadable\";\n\nexport type TextStreamController = {\n  append(textDelta: string): void;\n  close(): void; // TODO reason? error?\n};\n\nclass TextStreamControllerImpl implements TextStreamController {\n  private _controller: ReadableStreamDefaultController<AssistantStreamChunk>;\n  private _isClosed = false;\n\n  constructor(\n    controller: ReadableStreamDefaultController<AssistantStreamChunk>,\n  ) {\n    this._controller = controller;\n  }\n\n  append(textDelta: string) {\n    this._controller.enqueue({\n      type: \"text-delta\",\n      path: [],\n      textDelta,\n    });\n    return this;\n  }\n\n  close() {\n    if (this._isClosed) return;\n    this._isClosed = true;\n    this._controller.enqueue({\n      type: \"part-finish\",\n      path: [],\n    });\n    this._controller.close();\n  }\n}\n\nexport const createTextStream = (\n  readable: UnderlyingReadable<TextStreamController>,\n): AssistantStream => {\n  return new ReadableStream({\n    start(c) {\n      return readable.start?.(new TextStreamControllerImpl(c));\n    },\n    pull(c) {\n      return readable.pull?.(new TextStreamControllerImpl(c));\n    },\n    cancel(c) {\n      return readable.cancel?.(c);\n    },\n  });\n};\n\nexport const createTextStreamController = () => {\n  let controller!: TextStreamController;\n  const stream = createTextStream({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [stream, controller] as const;\n};\n"],"names":[],"mappings":";;;;;AASA,IAAM,2BAAN,MAA+D;IACrD,YAAA;IACA,YAAY,MAAA;IAEpB,YACE,UAAA,CACA;QACA,IAAA,CAAK,WAAA,GAAc;IACrB;IAEA,OAAO,SAAA,EAAmB;QACxB,IAAA,CAAK,WAAA,CAAY,OAAA,CAAQ;YACvB,MAAM;YACN,MAAM,CAAC,CAAA;YACP;QACF,CAAC;QACD,OAAO,IAAA;IACT;IAEA,QAAQ;QACN,IAAI,IAAA,CAAK,SAAA,CAAW,CAAA;QACpB,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,WAAA,CAAY,OAAA,CAAQ;YACvB,MAAM;YACN,MAAM,CAAC,CAAA;QACT,CAAC;QACD,IAAA,CAAK,WAAA,CAAY,KAAA,CAAM;IACzB;AACF;AAEO,IAAM,mBAAmB,CAC9B,aACoB;IACpB,OAAO,IAAI,eAAe;QACxB,OAAM,CAAA,EAAG;YACP,OAAO,SAAS,KAAA,GAAQ,IAAI,yBAAyB,CAAC,CAAC;QACzD;QACA,MAAK,CAAA,EAAG;YACN,OAAO,SAAS,IAAA,GAAO,IAAI,yBAAyB,CAAC,CAAC;QACxD;QACA,QAAO,CAAA,EAAG;YACR,OAAO,SAAS,MAAA,GAAS,CAAC;QAC5B;IACF,CAAC;AACH;AAEO,IAAM,6BAA6B,MAAM;IAC9C,IAAI;IACJ,MAAM,SAAS,iBAAiB;QAC9B,OAAM,CAAA,EAAG;YACP,aAAa;QACf;IACF,CAAC;IACD,OAAO;QAAC;QAAQ,UAAU;KAAA;AAC5B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1167, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/modules/tool-call.ts"],"sourcesContent":["import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { ToolResponseLike } from \"../tool/ToolResponse\";\nimport { ReadonlyJSONValue } from \"../../utils/json/json-value\";\nimport { UnderlyingReadable } from \"../utils/stream/UnderlyingReadable\";\nimport { createTextStream, TextStreamController } from \"./text\";\n\nexport type ToolCallStreamController = {\n  argsText: TextStreamController;\n\n  setResponse(response: ToolResponseLike<ReadonlyJSONValue>): void;\n  close(): void;\n};\n\nclass ToolCallStreamControllerImpl implements ToolCallStreamController {\n  private _isClosed = false;\n\n  private _mergeTask: Promise<void>;\n  constructor(\n    private _controller: ReadableStreamDefaultController<AssistantStreamChunk>,\n  ) {\n    const stream = createTextStream({\n      start: (c) => {\n        this._argsTextController = c;\n      },\n    });\n    this._mergeTask = stream.pipeTo(\n      new WritableStream({\n        write: (chunk) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              this._controller.enqueue(chunk);\n              break;\n\n            case \"part-finish\":\n              this._controller.enqueue({\n                type: \"tool-call-args-text-finish\",\n                path: [],\n              });\n              break;\n\n            default:\n              throw new Error(`Unexpected chunk type: ${chunk.type}`);\n          }\n        },\n      }),\n    );\n  }\n\n  get argsText() {\n    return this._argsTextController;\n  }\n\n  private _argsTextController!: TextStreamController;\n\n  async setResponse(response: ToolResponseLike<ReadonlyJSONValue>) {\n    this._argsTextController.close();\n    await Promise.resolve(); // flush microtask queue\n    // TODO switch argsTextController to be something that doesn'#t require this\n    this._controller.enqueue({\n      type: \"result\",\n      path: [],\n      ...(response.artifact !== undefined\n        ? { artifact: response.artifact }\n        : {}),\n      result: response.result,\n      isError: response.isError ?? false,\n    });\n  }\n\n  async close() {\n    if (this._isClosed) return;\n\n    this._isClosed = true;\n    this._argsTextController.close();\n    await this._mergeTask;\n\n    this._controller.enqueue({\n      type: \"part-finish\",\n      path: [],\n    });\n    this._controller.close();\n  }\n}\n\nexport const createToolCallStream = (\n  readable: UnderlyingReadable<ToolCallStreamController>,\n): AssistantStream => {\n  return new ReadableStream({\n    start(c) {\n      return readable.start?.(new ToolCallStreamControllerImpl(c));\n    },\n    pull(c) {\n      return readable.pull?.(new ToolCallStreamControllerImpl(c));\n    },\n    cancel(c) {\n      return readable.cancel?.(c);\n    },\n  });\n};\n\nexport const createToolCallStreamController = () => {\n  let controller!: ToolCallStreamController;\n  const stream = createToolCallStream({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [stream, controller] as const;\n};\n"],"names":[],"mappings":";;;;;AAKA,SAAS,wBAA8C;;AASvD,IAAM,+BAAN,MAAuE;IAIrE,YACU,WAAA,CACR;QADQ,IAAA,CAAA,WAAA,GAAA;QAER,MAAM,oLAAS,mBAAA,EAAiB;YAC9B,OAAO,CAAC,MAAM;gBACZ,IAAA,CAAK,mBAAA,GAAsB;YAC7B;QACF,CAAC;QACD,IAAA,CAAK,UAAA,GAAa,OAAO,MAAA,CACvB,IAAI,eAAe;YACjB,OAAO,CAAC,UAAU;gBAChB,OAAQ,MAAM,IAAA,EAAM;oBAClB,KAAK;wBACH,IAAA,CAAK,WAAA,CAAY,OAAA,CAAQ,KAAK;wBAC9B;oBAEF,KAAK;wBACH,IAAA,CAAK,WAAA,CAAY,OAAA,CAAQ;4BACvB,MAAM;4BACN,MAAM,CAAC,CAAA;wBACT,CAAC;wBACD;oBAEF;wBACE,MAAM,IAAI,MAAM,CAAA,uBAAA,EAA0B,MAAM,IAAI,EAAE;gBAC1D;YACF;QACF,CAAC;IAEL;IAhCQ,YAAY,MAAA;IAEZ,WAAA;IAgCR,IAAI,WAAW;QACb,OAAO,IAAA,CAAK,mBAAA;IACd;IAEQ,oBAAA;IAER,MAAM,YAAY,QAAA,EAA+C;QAC/D,IAAA,CAAK,mBAAA,CAAoB,KAAA,CAAM;QAC/B,MAAM,QAAQ,OAAA,CAAQ;QAEtB,IAAA,CAAK,WAAA,CAAY,OAAA,CAAQ;YACvB,MAAM;YACN,MAAM,CAAC,CAAA;YACP,GAAI,SAAS,QAAA,KAAa,KAAA,IACtB;gBAAE,UAAU,SAAS,QAAA;YAAS,IAC9B,CAAC,CAAA;YACL,QAAQ,SAAS,MAAA;YACjB,SAAS,SAAS,OAAA,IAAW;QAC/B,CAAC;IACH;IAEA,MAAM,QAAQ;QACZ,IAAI,IAAA,CAAK,SAAA,CAAW,CAAA;QAEpB,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,mBAAA,CAAoB,KAAA,CAAM;QAC/B,MAAM,IAAA,CAAK,UAAA;QAEX,IAAA,CAAK,WAAA,CAAY,OAAA,CAAQ;YACvB,MAAM;YACN,MAAM,CAAC,CAAA;QACT,CAAC;QACD,IAAA,CAAK,WAAA,CAAY,KAAA,CAAM;IACzB;AACF;AAEO,IAAM,uBAAuB,CAClC,aACoB;IACpB,OAAO,IAAI,eAAe;QACxB,OAAM,CAAA,EAAG;YACP,OAAO,SAAS,KAAA,GAAQ,IAAI,6BAA6B,CAAC,CAAC;QAC7D;QACA,MAAK,CAAA,EAAG;YACN,OAAO,SAAS,IAAA,GAAO,IAAI,6BAA6B,CAAC,CAAC;QAC5D;QACA,QAAO,CAAA,EAAG;YACR,OAAO,SAAS,MAAA,GAAS,CAAC;QAC5B;IACF,CAAC;AACH;AAEO,IAAM,iCAAiC,MAAM;IAClD,IAAI;IACJ,MAAM,SAAS,qBAAqB;QAClC,OAAM,CAAA,EAAG;YACP,aAAa;QACf;IACF,CAAC;IACD,OAAO;QAAC;QAAQ,UAAU;KAAA;AAC5B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1264, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/Counter.ts"],"sourcesContent":["export class Counter {\n  public value = -1;\n\n  up() {\n    return ++this.value;\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,IAAM,UAAN,MAAc;IACZ,QAAQ,CAAA,EAAA;IAEf,KAAK;QACH,OAAO,EAAE,IAAA,CAAK,KAAA;IAChB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1282, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/stream/path-utils.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { Counter } from \"../Counter\";\n\nexport class PathAppendEncoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(idx: number) {\n    super({\n      transform(chunk, controller) {\n        controller.enqueue({\n          ...chunk,\n          path: [idx, ...chunk.path],\n        });\n      },\n    });\n  }\n}\n\nexport class PathAppendDecoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(idx: number) {\n    super({\n      transform(chunk, controller) {\n        const {\n          path: [idx2, ...path],\n        } = chunk;\n\n        if (idx !== idx2)\n          throw new Error(`Path mismatch: expected ${idx}, got ${idx2}`);\n\n        controller.enqueue({\n          ...chunk,\n          path,\n        });\n      },\n    });\n  }\n}\n\nexport class PathMergeEncoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(counter: Counter) {\n    const innerCounter = new Counter();\n    const mapping = new Map<number, number>();\n    super({\n      transform(chunk, controller) {\n        if (chunk.type === \"part-start\" && chunk.path.length === 0) {\n          mapping.set(innerCounter.up(), counter.up());\n        }\n\n        const [idx, ...path] = chunk.path;\n        if (idx === undefined) {\n          controller.enqueue(chunk);\n          return;\n        }\n        const mappedIdx = mapping.get(idx);\n        if (mappedIdx === undefined) throw new Error(\"Path not found\");\n\n        controller.enqueue({\n          ...chunk,\n          path: [mappedIdx, ...path],\n        });\n      },\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;;AACA,SAAS,eAAe;;AAEjB,IAAM,oBAAN,cAAgC,gBAGrC;IACA,YAAY,GAAA,CAAa;QACvB,KAAA,CAAM;YACJ,WAAU,KAAA,EAAO,UAAA,EAAY;gBAC3B,WAAW,OAAA,CAAQ;oBACjB,GAAG,KAAA;oBACH,MAAM;wBAAC,KAAK;2BAAG,MAAM,IAAI;qBAAA;gBAC3B,CAAC;YACH;QACF,CAAC;IACH;AACF;AAEO,IAAM,oBAAN,cAAgC,gBAGrC;IACA,YAAY,GAAA,CAAa;QACvB,KAAA,CAAM;YACJ,WAAU,KAAA,EAAO,UAAA,EAAY;gBAC3B,MAAM,EACJ,MAAM,CAAC,MAAM,GAAG,IAAI,CAAA,EACtB,GAAI;gBAEJ,IAAI,QAAQ,MACV,MAAM,IAAI,MAAM,CAAA,wBAAA,EAA2B,GAAG,CAAA,MAAA,EAAS,IAAI,EAAE;gBAE/D,WAAW,OAAA,CAAQ;oBACjB,GAAG,KAAA;oBACH;gBACF,CAAC;YACH;QACF,CAAC;IACH;AACF;AAEO,IAAM,mBAAN,cAA+B,gBAGpC;IACA,YAAY,OAAA,CAAkB;QAC5B,MAAM,eAAe,4KAAI,UAAA,CAAQ;QACjC,MAAM,UAAU,aAAA,GAAA,IAAI,IAAoB;QACxC,KAAA,CAAM;YACJ,WAAU,KAAA,EAAO,UAAA,EAAY;gBAC3B,IAAI,MAAM,IAAA,KAAS,gBAAgB,MAAM,IAAA,CAAK,MAAA,KAAW,GAAG;oBAC1D,QAAQ,GAAA,CAAI,aAAa,EAAA,CAAG,GAAG,QAAQ,EAAA,CAAG,CAAC;gBAC7C;gBAEA,MAAM,CAAC,KAAK,GAAG,IAAI,CAAA,GAAI,MAAM,IAAA;gBAC7B,IAAI,QAAQ,KAAA,GAAW;oBACrB,WAAW,OAAA,CAAQ,KAAK;oBACxB;gBACF;gBACA,MAAM,YAAY,QAAQ,GAAA,CAAI,GAAG;gBACjC,IAAI,cAAc,KAAA,EAAW,CAAA,MAAM,IAAI,MAAM,gBAAgB;gBAE7D,WAAW,OAAA,CAAQ;oBACjB,GAAG,KAAA;oBACH,MAAM;wBAAC,WAAW;2BAAG,IAAI;qBAAA;gBAC3B,CAAC;YACH;QACF,CAAC;IACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1354, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/modules/assistant-stream.ts"],"sourcesContent":["import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk, PartInit } from \"../AssistantStreamChunk\";\nimport { createMergeStream } from \"../utils/stream/merge\";\nimport { createTextStreamController, TextStreamController } from \"./text\";\nimport {\n  createToolCallStreamController,\n  ToolCallStreamController,\n} from \"./tool-call\";\nimport { Counter } from \"../utils/Counter\";\nimport {\n  PathAppendEncoder,\n  PathMergeEncoder,\n} from \"../utils/stream/path-utils\";\nimport { DataStreamEncoder } from \"../serialization/data-stream/DataStream\";\nimport { FilePart, SourcePart } from \"../utils/types\";\nimport { generateId } from \"../utils/generateId\";\nimport {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from \"../../utils/json/json-value\";\nimport { ToolResponseLike } from \"../tool/ToolResponse\";\nimport { promiseWithResolvers } from \"../../utils/promiseWithResolvers\";\n\ntype ToolCallPartInit = {\n  toolCallId?: string;\n  toolName: string;\n  argsText?: string;\n  args?: ReadonlyJSONObject;\n  response?: ToolResponseLike<ReadonlyJSONValue>;\n};\n\nexport type AssistantStreamController = {\n  appendText(textDelta: string): void;\n  appendReasoning(reasoningDelta: string): void;\n  appendSource(options: SourcePart): void;\n  appendFile(options: FilePart): void;\n  addTextPart(): TextStreamController;\n  addToolCallPart(options: string): ToolCallStreamController;\n  addToolCallPart(options: ToolCallPartInit): ToolCallStreamController;\n  enqueue(chunk: AssistantStreamChunk): void;\n  merge(stream: AssistantStream): void;\n  close(): void;\n};\n\nclass AssistantStreamControllerImpl implements AssistantStreamController {\n  private _merger = createMergeStream();\n  private _append:\n    | {\n        controller: TextStreamController;\n        kind: \"text\" | \"reasoning\";\n      }\n    | undefined;\n  private _contentCounter = new Counter();\n\n  get __internal_isClosed() {\n    return this._merger.isSealed();\n  }\n\n  __internal_getReadable() {\n    return this._merger.readable;\n  }\n\n  private _closeSubscriber: undefined | (() => void);\n  __internal_subscribeToClose(callback: () => void) {\n    this._closeSubscriber = callback;\n  }\n\n  private _addPart(part: PartInit, stream: AssistantStream) {\n    if (this._append) {\n      this._append.controller.close();\n      this._append = undefined;\n    }\n\n    this.enqueue({\n      type: \"part-start\",\n      part,\n      path: [],\n    });\n    this._merger.addStream(\n      stream.pipeThrough(new PathAppendEncoder(this._contentCounter.value)),\n    );\n  }\n\n  merge(stream: AssistantStream) {\n    this._merger.addStream(\n      stream.pipeThrough(new PathMergeEncoder(this._contentCounter)),\n    );\n  }\n\n  appendText(textDelta: string) {\n    if (this._append?.kind !== \"text\") {\n      this._append = {\n        kind: \"text\",\n        controller: this.addTextPart(),\n      };\n    }\n    this._append.controller.append(textDelta);\n  }\n\n  appendReasoning(textDelta: string) {\n    if (this._append?.kind !== \"reasoning\") {\n      this._append = {\n        kind: \"reasoning\",\n        controller: this.addReasoningPart(),\n      };\n    }\n    this._append.controller.append(textDelta);\n  }\n\n  addTextPart() {\n    const [stream, controller] = createTextStreamController();\n    this._addPart({ type: \"text\" }, stream);\n    return controller;\n  }\n\n  addReasoningPart() {\n    const [stream, controller] = createTextStreamController();\n    this._addPart({ type: \"reasoning\" }, stream);\n    return controller;\n  }\n\n  addToolCallPart(\n    options: string | ToolCallPartInit,\n  ): ToolCallStreamController {\n    const opt = typeof options === \"string\" ? { toolName: options } : options;\n    const toolName = opt.toolName;\n    const toolCallId = opt.toolCallId ?? generateId();\n\n    const [stream, controller] = createToolCallStreamController();\n    this._addPart({ type: \"tool-call\", toolName, toolCallId }, stream);\n\n    if (opt.argsText !== undefined) {\n      controller.argsText.append(opt.argsText);\n      controller.argsText.close();\n    }\n    if (opt.args !== undefined) {\n      controller.argsText.append(JSON.stringify(opt.args));\n      controller.argsText.close();\n    }\n    if (opt.response !== undefined) {\n      controller.setResponse(opt.response);\n    }\n\n    return controller;\n  }\n\n  appendSource(options: SourcePart) {\n    this._addPart(\n      options,\n      new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"part-finish\",\n            path: [],\n          });\n          controller.close();\n        },\n      }),\n    );\n  }\n\n  appendFile(options: FilePart) {\n    this._addPart(\n      options,\n      new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"part-finish\",\n            path: [],\n          });\n          controller.close();\n        },\n      }),\n    );\n  }\n\n  enqueue(chunk: AssistantStreamChunk) {\n    this._merger.enqueue(chunk);\n\n    if (chunk.type === \"part-start\" && chunk.path.length === 0) {\n      this._contentCounter.up();\n    }\n  }\n\n  close() {\n    this._merger.seal();\n    this._append?.controller?.close();\n\n    this._closeSubscriber?.();\n  }\n}\n\nexport function createAssistantStream(\n  callback: (controller: AssistantStreamController) => PromiseLike<void> | void,\n): AssistantStream {\n  const controller = new AssistantStreamControllerImpl();\n\n  let promiseOrVoid: PromiseLike<void> | void;\n  try {\n    promiseOrVoid = callback(controller);\n  } catch (e) {\n    if (!controller.__internal_isClosed) {\n      controller.enqueue({\n        type: \"error\",\n        path: [],\n        error: String(e),\n      });\n      controller.close();\n    }\n    throw e;\n  }\n\n  if (promiseOrVoid instanceof Promise) {\n    const runTask = async () => {\n      try {\n        await promiseOrVoid;\n      } catch (e) {\n        if (!controller.__internal_isClosed) {\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(e),\n          });\n        }\n        throw e;\n      } finally {\n        if (!controller.__internal_isClosed) {\n          controller.close();\n        }\n      }\n    };\n    runTask();\n  } else {\n    if (!controller.__internal_isClosed) {\n      controller.close();\n    }\n  }\n\n  return controller.__internal_getReadable();\n}\n\nexport function createAssistantStreamController() {\n  const { resolve, promise } = promiseWithResolvers<void>();\n  let controller!: AssistantStreamController;\n  const stream = createAssistantStream((c) => {\n    controller = c;\n\n    (controller as AssistantStreamControllerImpl).__internal_subscribeToClose(\n      resolve,\n    );\n\n    return promise;\n  });\n  return [stream, controller] as const;\n}\n\nexport function createAssistantStreamResponse(\n  callback: (controller: AssistantStreamController) => PromiseLike<void> | void,\n) {\n  return AssistantStream.toResponse(\n    createAssistantStream(callback),\n    new DataStreamEncoder(),\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1565, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/stream/AssistantTransformStream.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport {\n  AssistantStreamController,\n  createAssistantStreamController,\n} from \"../../modules/assistant-stream\";\n\ntype AssistantTransformerFlushCallback = (\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformerStartCallback = (\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformerTransformCallback<I> = (\n  chunk: I,\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformer<I> = {\n  flush?: AssistantTransformerFlushCallback;\n  start?: AssistantTransformerStartCallback;\n  transform?: AssistantTransformerTransformCallback<I>;\n};\n\nexport class AssistantTransformStream<I> extends TransformStream<\n  I,\n  AssistantStreamChunk\n> {\n  constructor(\n    transformer: AssistantTransformer<I>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<AssistantStreamChunk>,\n  ) {\n    const [stream, runController] = createAssistantStreamController();\n\n    let runPipeTask: Promise<void>;\n    super(\n      {\n        start(controller) {\n          runPipeTask = stream\n            .pipeTo(\n              new WritableStream({\n                write(chunk) {\n                  controller.enqueue(chunk);\n                },\n                abort(reason?: any) {\n                  controller.error(reason);\n                },\n                close() {\n                  controller.terminate();\n                },\n              }),\n            )\n            .catch((error) => {\n              controller.error(error);\n            });\n\n          return transformer.start?.(runController);\n        },\n        transform(chunk) {\n          return transformer.transform?.(chunk, runController);\n        },\n        async flush() {\n          await transformer.flush?.(runController);\n          runController.close();\n          await runPipeTask;\n        },\n      },\n      writableStrategy,\n      readableStrategy,\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AACA;;AAwBO,IAAM,2BAAN,cAA0C,gBAG/C;IACA,YACE,WAAA,EACA,gBAAA,EACA,gBAAA,CACA;QACA,MAAM,CAAC,QAAQ,aAAa,CAAA,6LAAI,kCAAA,CAAgC;QAEhE,IAAI;QACJ,KAAA,CACE;YACE,OAAM,UAAA,EAAY;gBAChB,cAAc,OACX,MAAA,CACC,IAAI,eAAe;oBACjB,OAAM,KAAA,EAAO;wBACX,WAAW,OAAA,CAAQ,KAAK;oBAC1B;oBACA,OAAM,MAAA,EAAc;wBAClB,WAAW,KAAA,CAAM,MAAM;oBACzB;oBACA,QAAQ;wBACN,WAAW,SAAA,CAAU;oBACvB;gBACF,CAAC,GAEF,KAAA,CAAM,CAAC,UAAU;oBAChB,WAAW,KAAA,CAAM,KAAK;gBACxB,CAAC;gBAEH,OAAO,YAAY,KAAA,GAAQ,aAAa;YAC1C;YACA,WAAU,KAAA,EAAO;gBACf,OAAO,YAAY,SAAA,GAAY,OAAO,aAAa;YACrD;YACA,MAAM,QAAQ;gBACZ,MAAM,YAAY,KAAA,GAAQ,aAAa;gBACvC,cAAc,KAAA,CAAM;gBACpB,MAAM;YACR;QACF,GACA,kBACA;IAEJ;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1611, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/stream/PipeableTransformStream.ts"],"sourcesContent":["export class PipeableTransformStream<I, O> extends TransformStream<I, O> {\n  constructor(transform: (readable: ReadableStream<I>) => ReadableStream<O>) {\n    super();\n    const readable = transform(super.readable as unknown as ReadableStream<I>);\n    Object.defineProperty(this, \"readable\", {\n      value: readable,\n      writable: false,\n    });\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,IAAM,0BAAN,cAA4C,gBAAsB;IACvE,YAAY,SAAA,CAA+D;QACzE,KAAA,CAAM;QACN,MAAM,WAAW,UAAU,KAAA,CAAM,QAAwC;QACzE,OAAO,cAAA,CAAe,IAAA,EAAM,YAAY;YACtC,OAAO;YACP,UAAU;QACZ,CAAC;IACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1633, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/serialization/data-stream/chunk-types.ts"],"sourcesContent":["import {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from \"../../../utils/json/json-value\";\nimport { ObjectStreamOperation } from \"../../object/types\";\n\nexport type DataStreamChunk = {\n  [K in DataStreamStreamChunkType]: {\n    type: K;\n    value: DataStreamStreamChunkValue[K];\n  };\n}[DataStreamStreamChunkType];\n\ntype LanguageModelV1FinishReason =\n  | \"stop\"\n  | \"length\"\n  | \"content-filter\"\n  | \"tool-calls\"\n  | \"error\"\n  | \"other\"\n  | \"unknown\";\n\ntype LanguageModelV1Usage = {\n  promptTokens: number;\n  completionTokens: number;\n};\n\nexport enum DataStreamStreamChunkType {\n  TextDelta = \"0\",\n  Data = \"2\",\n  Error = \"3\",\n  Annotation = \"8\",\n  ToolCall = \"9\",\n  ToolCallResult = \"a\",\n  StartToolCall = \"b\",\n  ToolCallArgsTextDelta = \"c\",\n  FinishMessage = \"d\",\n  FinishStep = \"e\",\n  StartStep = \"f\",\n  ReasoningDelta = \"g\",\n  Source = \"h\",\n  RedactedReasoning = \"i\",\n  ReasoningSignature = \"j\",\n  File = \"k\",\n\n  AuiUpdateStateOperations = \"aui-state\",\n}\ntype DataStreamStreamChunkValue = {\n  [DataStreamStreamChunkType.TextDelta]: string;\n  [DataStreamStreamChunkType.Data]: ReadonlyJSONValue[];\n  [DataStreamStreamChunkType.Annotation]: ReadonlyJSONValue[];\n  [DataStreamStreamChunkType.ToolCall]: {\n    toolCallId: string;\n    toolName: string;\n    args: ReadonlyJSONObject;\n  };\n  [DataStreamStreamChunkType.StartToolCall]: {\n    toolCallId: string;\n    toolName: string;\n  };\n  [DataStreamStreamChunkType.ToolCallArgsTextDelta]: {\n    toolCallId: string;\n    argsTextDelta: string;\n  };\n  [DataStreamStreamChunkType.ToolCallResult]: {\n    toolCallId: string;\n    result: ReadonlyJSONValue;\n\n    // aui-extensions\n    artifact?: ReadonlyJSONValue | undefined;\n    isError?: boolean;\n  };\n  [DataStreamStreamChunkType.Error]: string;\n  [DataStreamStreamChunkType.FinishStep]: {\n    finishReason: LanguageModelV1FinishReason;\n    usage: LanguageModelV1Usage;\n    isContinued: boolean;\n  };\n  [DataStreamStreamChunkType.FinishMessage]: {\n    finishReason: LanguageModelV1FinishReason;\n    usage: LanguageModelV1Usage;\n  };\n  [DataStreamStreamChunkType.StartStep]: {\n    messageId: string;\n  };\n  [DataStreamStreamChunkType.ReasoningDelta]: string;\n  [DataStreamStreamChunkType.Source]: {\n    sourceType: \"url\";\n    id: string;\n    url: string;\n    title?: string;\n  };\n  [DataStreamStreamChunkType.RedactedReasoning]: { data: string };\n  [DataStreamStreamChunkType.ReasoningSignature]: { signature: string };\n  [DataStreamStreamChunkType.File]: { data: string; mimeType: string };\n\n  // aui-extensions\n  [DataStreamStreamChunkType.AuiUpdateStateOperations]: ObjectStreamOperation[];\n};\n"],"names":["DataStreamStreamChunkType"],"mappings":";;;;AA2BO,IAAK,4BAAL,aAAA,GAAA,CAAA,CAAKA,+BAAL;IACLA,0BAAAA,CAAA,YAAA,GAAY;IACZA,0BAAAA,CAAA,OAAA,GAAO;IACPA,0BAAAA,CAAA,QAAA,GAAQ;IACRA,0BAAAA,CAAA,aAAA,GAAa;IACbA,0BAAAA,CAAA,WAAA,GAAW;IACXA,0BAAAA,CAAA,iBAAA,GAAiB;IACjBA,0BAAAA,CAAA,gBAAA,GAAgB;IAChBA,0BAAAA,CAAA,wBAAA,GAAwB;IACxBA,0BAAAA,CAAA,gBAAA,GAAgB;IAChBA,0BAAAA,CAAA,aAAA,GAAa;IACbA,0BAAAA,CAAA,YAAA,GAAY;IACZA,0BAAAA,CAAA,iBAAA,GAAiB;IACjBA,0BAAAA,CAAA,SAAA,GAAS;IACTA,0BAAAA,CAAA,oBAAA,GAAoB;IACpBA,0BAAAA,CAAA,qBAAA,GAAqB;IACrBA,0BAAAA,CAAA,OAAA,GAAO;IAEPA,0BAAAA,CAAA,2BAAA,GAA2B;IAlBjB,OAAAA;AAAA,CAAA,EAAA,6BAAA,CAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1665, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/stream/LineDecoderStream.ts"],"sourcesContent":["export class LineDecoderStream extends TransformStream<string, string> {\n  private buffer = \"\";\n\n  constructor() {\n    super({\n      transform: (chunk, controller) => {\n        this.buffer += chunk;\n        const lines = this.buffer.split(\"\\n\");\n\n        // Process all complete lines\n        for (let i = 0; i < lines.length - 1; i++) {\n          controller.enqueue(lines[i]);\n        }\n\n        // Keep the last incomplete line in the buffer\n        this.buffer = lines[lines.length - 1] || \"\";\n      },\n      flush: () => {\n        // If there's content in the buffer when the stream ends, it means\n        // the stream ended with an incomplete line (no trailing newline)\n        if (this.buffer) {\n          throw new Error(\n            `Stream ended with an incomplete line: \"${this.buffer}\"`,\n          );\n        }\n      },\n    });\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,IAAM,oBAAN,cAAgC,gBAAgC;IAC7D,SAAS,GAAA;IAEjB,aAAc;QACZ,KAAA,CAAM;YACJ,WAAW,CAAC,OAAO,eAAe;gBAChC,IAAA,CAAK,MAAA,IAAU;gBACf,MAAM,QAAQ,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,IAAI;gBAGpC,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,GAAS,GAAG,IAAK;oBACzC,WAAW,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAC;gBAC7B;gBAGA,IAAA,CAAK,MAAA,GAAS,KAAA,CAAM,MAAM,MAAA,GAAS,CAAC,CAAA,IAAK;YAC3C;YACA,OAAO,MAAM;gBAGX,IAAI,IAAA,CAAK,MAAA,EAAQ;oBACf,MAAM,IAAI,MACR,CAAA,uCAAA,EAA0C,IAAA,CAAK,MAAM,CAAA,CAAA,CAAA;gBAEzD;YACF;QACF,CAAC;IACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1697, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/serialization/data-stream/serialization.ts"],"sourcesContent":["import { DataStreamChunk, DataStreamStreamChunkType } from \"./chunk-types\";\n\nexport class DataStreamChunkEncoder extends TransformStream<\n  DataStreamChunk,\n  string\n> {\n  constructor() {\n    super({\n      transform: (chunk, controller) => {\n        controller.enqueue(`${chunk.type}:${JSON.stringify(chunk.value)}\\n`);\n      },\n    });\n  }\n}\n\nexport class DataStreamChunkDecoder extends TransformStream<\n  string,\n  DataStreamChunk\n> {\n  constructor() {\n    super({\n      transform: (chunk, controller) => {\n        const index = chunk.indexOf(\":\");\n        if (index === -1) throw new Error(\"Invalid stream part\");\n        controller.enqueue({\n          type: chunk.slice(0, index) as DataStreamStreamChunkType,\n          value: JSON.parse(chunk.slice(index + 1)),\n        });\n      },\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;AAEO,IAAM,yBAAN,cAAqC,gBAG1C;IACA,aAAc;QACZ,KAAA,CAAM;YACJ,WAAW,CAAC,OAAO,eAAe;gBAChC,WAAW,OAAA,CAAQ,GAAG,MAAM,IAAI,CAAA,CAAA,EAAI,KAAK,SAAA,CAAU,MAAM,KAAK,CAAC,CAAA;AAAA,CAAI;YACrE;QACF,CAAC;IACH;AACF;AAEO,IAAM,yBAAN,cAAqC,gBAG1C;IACA,aAAc;QACZ,KAAA,CAAM;YACJ,WAAW,CAAC,OAAO,eAAe;gBAChC,MAAM,QAAQ,MAAM,OAAA,CAAQ,GAAG;gBAC/B,IAAI,UAAU,CAAA,EAAI,CAAA,MAAM,IAAI,MAAM,qBAAqB;gBACvD,WAAW,OAAA,CAAQ;oBACjB,MAAM,MAAM,KAAA,CAAM,GAAG,KAAK;oBAC1B,OAAO,KAAK,KAAA,CAAM,MAAM,KAAA,CAAM,QAAQ,CAAC,CAAC;gBAC1C,CAAC;YACH;QACF,CAAC;IACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1734, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/stream/AssistantMetaTransformStream.ts"],"sourcesContent":["import { AssistantStreamChunk, PartInit } from \"../../AssistantStreamChunk\";\n\n/**\n * For chunk types that are associated with a part,\n * we require a nonnullable meta field.\n */\nexport type AssistantMetaStreamChunk =\n  | (AssistantStreamChunk & {\n      type: \"text-delta\" | \"part-finish\";\n      meta: PartInit;\n    })\n  | (AssistantStreamChunk & {\n      type: \"result\" | \"tool-call-args-text-finish\";\n      meta: PartInit & { type: \"tool-call\" };\n    })\n  | (AssistantStreamChunk & {\n      type: Exclude<\n        AssistantStreamChunk[\"type\"],\n        \"text-delta\" | \"result\" | \"tool-call-args-text-finish\" | \"part-finish\"\n      >;\n    });\nexport class AssistantMetaTransformStream extends TransformStream<\n  AssistantStreamChunk,\n  AssistantMetaStreamChunk\n> {\n  constructor() {\n    // We use an array to record parts as they are introduced.\n    const parts: PartInit[] = [];\n\n    super({\n      transform(chunk, controller) {\n        // For chunks that introduce a new part.\n        if (chunk.type === \"part-start\") {\n          if (chunk.path.length !== 0) {\n            controller.error(new Error(\"Nested parts are not supported\"));\n            return;\n          }\n          parts.push(chunk.part);\n          controller.enqueue(chunk);\n          return;\n        }\n\n        // For chunks that expect an associated part.\n        if (\n          chunk.type === \"text-delta\" ||\n          chunk.type === \"result\" ||\n          chunk.type === \"part-finish\" ||\n          chunk.type === \"tool-call-args-text-finish\"\n        ) {\n          if (chunk.path.length !== 1) {\n            controller.error(\n              new Error(`${chunk.type} chunks must have a path of length 1`),\n            );\n            return;\n          }\n          const idx = chunk.path[0]!;\n          if (idx < 0 || idx >= parts.length) {\n            controller.error(new Error(`Invalid path index: ${idx}`));\n            return;\n          }\n          const part = parts[idx]!;\n\n          controller.enqueue({\n            ...chunk,\n            meta: part as any, // TODO\n          });\n          return;\n        }\n\n        controller.enqueue(chunk);\n      },\n    });\n  }\n}\n"],"names":[],"mappings":";;;;AAqBO,IAAM,+BAAN,cAA2C,gBAGhD;IACA,aAAc;QAEZ,MAAM,QAAoB,CAAC,CAAA;QAE3B,KAAA,CAAM;YACJ,WAAU,KAAA,EAAO,UAAA,EAAY;gBAE3B,IAAI,MAAM,IAAA,KAAS,cAAc;oBAC/B,IAAI,MAAM,IAAA,CAAK,MAAA,KAAW,GAAG;wBAC3B,WAAW,KAAA,CAAM,IAAI,MAAM,gCAAgC,CAAC;wBAC5D;oBACF;oBACA,MAAM,IAAA,CAAK,MAAM,IAAI;oBACrB,WAAW,OAAA,CAAQ,KAAK;oBACxB;gBACF;gBAGA,IACE,MAAM,IAAA,KAAS,gBACf,MAAM,IAAA,KAAS,YACf,MAAM,IAAA,KAAS,iBACf,MAAM,IAAA,KAAS,8BACf;oBACA,IAAI,MAAM,IAAA,CAAK,MAAA,KAAW,GAAG;wBAC3B,WAAW,KAAA,CACT,IAAI,MAAM,GAAG,MAAM,IAAI,CAAA,oCAAA,CAAsC;wBAE/D;oBACF;oBACA,MAAM,MAAM,MAAM,IAAA,CAAK,CAAC,CAAA;oBACxB,IAAI,MAAM,KAAK,OAAO,MAAM,MAAA,EAAQ;wBAClC,WAAW,KAAA,CAAM,IAAI,MAAM,CAAA,oBAAA,EAAuB,GAAG,EAAE,CAAC;wBACxD;oBACF;oBACA,MAAM,OAAO,KAAA,CAAM,GAAG,CAAA;oBAEtB,WAAW,OAAA,CAAQ;wBACjB,GAAG,KAAA;wBACH,MAAM;oBACR,CAAC;oBACD;gBACF;gBAEA,WAAW,OAAA,CAAQ,KAAK;YAC1B;QACF,CAAC;IACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1782, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/serialization/data-stream/DataStream.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { ToolCallStreamController } from \"../../modules/tool-call\";\nimport { AssistantTransformStream } from \"../../utils/stream/AssistantTransformStream\";\nimport { PipeableTransformStream } from \"../../utils/stream/PipeableTransformStream\";\nimport { DataStreamChunk, DataStreamStreamChunkType } from \"./chunk-types\";\nimport { LineDecoderStream } from \"../../utils/stream/LineDecoderStream\";\nimport {\n  DataStreamChunkDecoder,\n  DataStreamChunkEncoder,\n} from \"./serialization\";\nimport {\n  AssistantMetaStreamChunk,\n  AssistantMetaTransformStream,\n} from \"../../utils/stream/AssistantMetaTransformStream\";\nimport { TextStreamController } from \"../../modules/text\";\nimport { AssistantStreamEncoder } from \"../../AssistantStream\";\n\nexport class DataStreamEncoder\n  extends PipeableTransformStream<AssistantStreamChunk, Uint8Array>\n  implements AssistantStreamEncoder\n{\n  headers = new Headers({\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    \"x-vercel-ai-data-stream\": \"v1\",\n  });\n\n  constructor() {\n    super((readable) => {\n      const transform = new TransformStream<\n        AssistantMetaStreamChunk,\n        DataStreamChunk\n      >({\n        transform(chunk, controller) {\n          const type = chunk.type;\n          switch (type) {\n            case \"part-start\": {\n              const part = chunk.part;\n              if (part.type === \"tool-call\") {\n                const { type, ...value } = part;\n                controller.enqueue({\n                  type: DataStreamStreamChunkType.StartToolCall,\n                  value,\n                });\n              }\n              if (part.type === \"source\") {\n                const { type, ...value } = part;\n                controller.enqueue({\n                  type: DataStreamStreamChunkType.Source,\n                  value,\n                });\n              }\n              break;\n            }\n            case \"text-delta\": {\n              const part = chunk.meta;\n              switch (part.type) {\n                case \"text\": {\n                  controller.enqueue({\n                    type: DataStreamStreamChunkType.TextDelta,\n                    value: chunk.textDelta,\n                  });\n                  break;\n                }\n                case \"reasoning\": {\n                  controller.enqueue({\n                    type: DataStreamStreamChunkType.ReasoningDelta,\n                    value: chunk.textDelta,\n                  });\n                  break;\n                }\n                case \"tool-call\": {\n                  controller.enqueue({\n                    type: DataStreamStreamChunkType.ToolCallArgsTextDelta,\n                    value: {\n                      toolCallId: part.toolCallId,\n                      argsTextDelta: chunk.textDelta,\n                    },\n                  });\n                  break;\n                }\n                default:\n                  throw new Error(\n                    `Unsupported part type for text-delta: ${part.type}`,\n                  );\n              }\n              break;\n            }\n            case \"result\": {\n              // Only tool-call parts can have results.\n              const part = chunk.meta;\n              if (part.type !== \"tool-call\") {\n                throw new Error(\n                  `Result chunk on non-tool-call part not supported: ${part.type}`,\n                );\n              }\n              controller.enqueue({\n                type: DataStreamStreamChunkType.ToolCallResult,\n                value: {\n                  toolCallId: part.toolCallId,\n                  result: chunk.result,\n                  artifact: chunk.artifact,\n                  ...(chunk.isError ? { isError: chunk.isError } : {}),\n                },\n              });\n              break;\n            }\n            case \"step-start\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.StartStep,\n                value,\n              });\n              break;\n            }\n            case \"step-finish\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.FinishStep,\n                value,\n              });\n              break;\n            }\n            case \"message-finish\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.FinishMessage,\n                value,\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Error,\n                value: chunk.error,\n              });\n              break;\n            }\n            case \"annotations\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Annotation,\n                value: chunk.annotations,\n              });\n              break;\n            }\n            case \"data\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Data,\n                value: chunk.data,\n              });\n              break;\n            }\n\n            case \"update-state\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.AuiUpdateStateOperations,\n                value: chunk.operations,\n              });\n              break;\n            }\n\n            // TODO ignore for now\n            // in the future, we should create a handler that waits for text parts to finish before continuing\n            case \"tool-call-args-text-finish\":\n            case \"part-finish\":\n              break;\n\n            default: {\n              const exhaustiveCheck: never = type;\n              throw new Error(`Unsupported chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n      });\n\n      return readable\n        .pipeThrough(new AssistantMetaTransformStream())\n        .pipeThrough(transform)\n        .pipeThrough(new DataStreamChunkEncoder())\n        .pipeThrough(new TextEncoderStream());\n    });\n  }\n}\n\nconst TOOL_CALL_ARGS_CLOSING_CHUNKS = [\n  DataStreamStreamChunkType.StartToolCall,\n  DataStreamStreamChunkType.ToolCall,\n  DataStreamStreamChunkType.TextDelta,\n  DataStreamStreamChunkType.ReasoningDelta,\n  DataStreamStreamChunkType.Source,\n  DataStreamStreamChunkType.Error,\n  DataStreamStreamChunkType.FinishStep,\n  DataStreamStreamChunkType.FinishMessage,\n];\n\nexport class DataStreamDecoder extends PipeableTransformStream<\n  Uint8Array,\n  AssistantStreamChunk\n> {\n  constructor() {\n    super((readable) => {\n      const toolCallControllers = new Map<string, ToolCallStreamController>();\n      let activeToolCallArgsText: TextStreamController | undefined;\n      const transform = new AssistantTransformStream<DataStreamChunk>({\n        transform(chunk, controller) {\n          const { type, value } = chunk;\n\n          if (TOOL_CALL_ARGS_CLOSING_CHUNKS.includes(type)) {\n            activeToolCallArgsText?.close();\n            activeToolCallArgsText = undefined;\n          }\n\n          switch (type) {\n            case DataStreamStreamChunkType.ReasoningDelta:\n              controller.appendReasoning(value);\n              break;\n\n            case DataStreamStreamChunkType.TextDelta:\n              controller.appendText(value);\n              break;\n\n            case DataStreamStreamChunkType.StartToolCall: {\n              const { toolCallId, toolName } = value;\n              const toolCallController = controller.addToolCallPart({\n                toolCallId,\n                toolName,\n              });\n              toolCallControllers.set(toolCallId, toolCallController);\n\n              activeToolCallArgsText = toolCallController.argsText;\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCallArgsTextDelta: {\n              const { toolCallId, argsTextDelta } = value;\n              const toolCallController = toolCallControllers.get(toolCallId);\n              if (!toolCallController)\n                throw new Error(\n                  \"Encountered tool call with unknown id: \" + toolCallId,\n                );\n              toolCallController.argsText.append(argsTextDelta);\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCallResult: {\n              const { toolCallId, artifact, result, isError } = value;\n              const toolCallController = toolCallControllers.get(toolCallId);\n              if (!toolCallController)\n                throw new Error(\n                  \"Encountered tool call result with unknown id: \" + toolCallId,\n                );\n              toolCallController.setResponse({\n                artifact,\n                result,\n                isError,\n              });\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCall: {\n              const { toolCallId, toolName, args } = value;\n\n              let toolCallController = toolCallControllers.get(toolCallId);\n              if (toolCallController) {\n                toolCallController.argsText.close();\n              } else {\n                toolCallController = controller.addToolCallPart({\n                  toolCallId,\n                  toolName,\n                  args,\n                });\n                toolCallControllers.set(toolCallId, toolCallController);\n              }\n              break;\n            }\n\n            case DataStreamStreamChunkType.FinishMessage:\n              controller.enqueue({\n                type: \"message-finish\",\n                path: [],\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.StartStep:\n              controller.enqueue({\n                type: \"step-start\",\n                path: [],\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.FinishStep:\n              controller.enqueue({\n                type: \"step-finish\",\n                path: [],\n                ...value,\n              });\n              break;\n            case DataStreamStreamChunkType.Data:\n              controller.enqueue({\n                type: \"data\",\n                path: [],\n                data: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.Annotation:\n              controller.enqueue({\n                type: \"annotations\",\n                path: [],\n                annotations: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.Source:\n              controller.appendSource({\n                type: \"source\",\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.Error:\n              controller.enqueue({\n                type: \"error\",\n                path: [],\n                error: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.File:\n              controller.appendFile({\n                type: \"file\",\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.AuiUpdateStateOperations:\n              controller.enqueue({\n                type: \"update-state\",\n                path: [],\n                operations: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.ReasoningSignature:\n            case DataStreamStreamChunkType.RedactedReasoning:\n              // ignore these for now\n              break;\n\n            default: {\n              const exhaustiveCheck: never = type;\n              throw new Error(`unsupported chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n        flush() {\n          activeToolCallArgsText?.close();\n          activeToolCallArgsText = undefined;\n          toolCallControllers.forEach((controller) => controller.close());\n          toolCallControllers.clear();\n        },\n      });\n\n      return readable\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new LineDecoderStream())\n        .pipeThrough(new DataStreamChunkDecoder())\n        .pipeThrough(transform);\n    });\n  }\n}\n"],"names":["type"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2126, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/tool/ToolResponse.ts"],"sourcesContent":["import { ReadonlyJSONValue } from \"../../utils/json/json-value\";\n\nconst TOOL_RESPONSE_SYMBOL = Symbol.for(\"aui.tool-response\");\n\nexport type ToolResponseLike<TResult> = {\n  result: TResult;\n  artifact?: ReadonlyJSONValue | undefined;\n  isError?: boolean | undefined;\n};\n\nexport class ToolResponse<TResult> {\n  get [TOOL_RESPONSE_SYMBOL]() {\n    return true;\n  }\n\n  readonly artifact?: ReadonlyJSONValue;\n  readonly result: TResult;\n  readonly isError: boolean;\n\n  constructor(options: ToolResponseLike<TResult>) {\n    if (options.artifact !== undefined) {\n      this.artifact = options.artifact;\n    }\n    this.result = options.result;\n    this.isError = options.isError ?? false;\n  }\n\n  static [Symbol.hasInstance](\n    obj: unknown,\n  ): obj is ToolResponse<ReadonlyJSONValue> {\n    return (\n      typeof obj === \"object\" && obj !== null && TOOL_RESPONSE_SYMBOL in obj\n    );\n  }\n\n  static toResponse(result: any | ToolResponse<any>): ToolResponse<any> {\n    if (result instanceof ToolResponse) {\n      return result;\n    }\n    return new ToolResponse({\n      result: result === undefined ? \"<no result>\" : result,\n    });\n  }\n}\n"],"names":[],"mappings":";;;;AAEA,IAAM,uBAAuB,OAAO,GAAA,CAAI,mBAAmB;AAQpD,IAAM,eAAN,MAAM,cAAsB;IACjC,IAAA,CAAK,oBAAoB,CAAA,GAAI;QAC3B,OAAO;IACT;IAES,SAAA;IACA,OAAA;IACA,QAAA;IAET,YAAY,OAAA,CAAoC;QAC9C,IAAI,QAAQ,QAAA,KAAa,KAAA,GAAW;YAClC,IAAA,CAAK,QAAA,GAAW,QAAQ,QAAA;QAC1B;QACA,IAAA,CAAK,MAAA,GAAS,QAAQ,MAAA;QACtB,IAAA,CAAK,OAAA,GAAU,QAAQ,OAAA,IAAW;IACpC;IAEA,OAAA,CAAQ,OAAO,WAAW,CAAA,CACxB,GAAA,EACwC;QACxC,OACE,OAAO,QAAQ,YAAY,QAAQ,QAAQ,wBAAwB;IAEvE;IAEA,OAAO,WAAW,MAAA,EAAoD;QACpE,IAAI,kBAAkB,eAAc;YAClC,OAAO;QACT;QACA,OAAO,IAAI,cAAa;YACtB,QAAQ,WAAW,KAAA,IAAY,gBAAgB;QACjD,CAAC;IACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2165, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/utils/withPromiseOrValue.ts"],"sourcesContent":["export function withPromiseOrValue<T>(\n  callback: () => T | PromiseLike<T>,\n  thenHandler: (value: T) => PromiseLike<void> | void,\n  catchHandler: (error: unknown) => PromiseLike<void> | void,\n): PromiseLike<void> | void {\n  try {\n    const promiseOrValue = callback();\n    if (\n      typeof promiseOrValue === \"object\" &&\n      promiseOrValue !== null &&\n      \"then\" in promiseOrValue\n    ) {\n      return promiseOrValue.then(thenHandler, catchHandler);\n    } else {\n      thenHandler(promiseOrValue);\n    }\n  } catch (e) {\n    catchHandler(e);\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,mBACd,QAAA,EACA,WAAA,EACA,YAAA,EAC0B;IAC1B,IAAI;QACF,MAAM,iBAAiB,SAAS;QAChC,IACE,OAAO,mBAAmB,YAC1B,mBAAmB,QACnB,UAAU,gBACV;YACA,OAAO,eAAe,IAAA,CAAK,aAAa,YAAY;QACtD,OAAO;YACL,YAAY,cAAc;QAC5B;IACF,EAAA,OAAS,GAAG;QACV,aAAa,CAAC;IAChB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2189, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/utils/AsyncIterableStream.ts"],"sourcesContent":["export type AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\nasync function* streamGeneratorPolyfill<T>(\n  this: ReadableStream<T>,\n): AsyncIterator<T, undefined, unknown> {\n  const reader = this.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function asAsyncIterableStream<T>(\n  source: ReadableStream<T>,\n): AsyncIterableStream<T> {\n  (source as AsyncIterableStream<T>)[Symbol.asyncIterator] ??=\n    streamGeneratorPolyfill;\n  return source as AsyncIterableStream<T>;\n}\n"],"names":[],"mappings":";;;;AAEA,gBAAgB,0BAEwB;IACtC,MAAM,SAAS,IAAA,CAAK,SAAA,CAAU;IAC9B,IAAI;QACF,MAAO,KAAM;YACX,MAAM,EAAE,IAAA,EAAM,KAAA,CAAM,CAAA,GAAI,MAAM,OAAO,IAAA,CAAK;YAC1C,IAAI,KAAM,CAAA;YACV,MAAM;QACR;IACF,SAAE;QACA,OAAO,WAAA,CAAY;IACrB;AACF;AAEO,SAAS,sBACd,MAAA,EACwB;IACvB,MAAA,CAAkC,OAAO,aAAa,CAAA,KACrD;IACF,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2217, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/tool/ToolCallReader.ts"],"sourcesContent":["import { promiseWithResolvers } from \"../../utils/promiseWithResolvers\";\nimport {\n  parsePartialJsonObject,\n  getPartialJsonObjectFieldState,\n} from \"../../utils/json/parse-partial-json-object\";\nimport {\n  ToolCallArgsReader,\n  ToolCallReader,\n  ToolCallResponseReader,\n} from \"./tool-types\";\nimport { DeepPartial, TypeAtPath, TypePath } from \"./type-path-utils\";\nimport { ToolResponse } from \"./ToolResponse\";\nimport {\n  asAsyncIterableStream,\n  AsyncIterableStream,\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from \"../../utils\";\n\n// TODO: remove dispose\n\nfunction getField<T>(obj: T, fieldPath: (string | number)[]): unknown {\n  let current: unknown = obj;\n  for (const key of fieldPath) {\n    if (current === undefined || current === null) {\n      return undefined;\n    }\n    current = current[key as keyof typeof current];\n  }\n  return current;\n}\n\ninterface Handle {\n  update(args: unknown): void;\n  dispose(): void;\n}\n\nclass GetHandle<T, TValue> implements Handle {\n  private resolve: (value: TValue) => void;\n  private reject: (reason: unknown) => void;\n  private disposed = false;\n  private fieldPath: (string | number)[];\n\n  constructor(\n    resolve: (value: TValue) => void,\n    reject: (reason: unknown) => void,\n    fieldPath: (string | number)[],\n  ) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.fieldPath = fieldPath;\n  }\n\n  update(args: unknown): void {\n    if (this.disposed) return;\n\n    try {\n      // Check if the field is complete\n      if (\n        getPartialJsonObjectFieldState(\n          args as Record<string, unknown>,\n          this.fieldPath,\n        ) === \"complete\"\n      ) {\n        const value = getField(args as T, this.fieldPath);\n        if (value !== undefined) {\n          this.resolve(value as TValue);\n          this.dispose();\n        }\n      }\n    } catch (e) {\n      this.reject(e);\n      this.dispose();\n    }\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n}\n\nclass StreamValuesHandle<T> implements Handle {\n  private controller: ReadableStreamDefaultController<unknown>;\n  private disposed = false;\n  private fieldPath: (string | number)[];\n\n  constructor(\n    controller: ReadableStreamDefaultController<unknown>,\n    fieldPath: (string | number)[],\n  ) {\n    this.controller = controller;\n    this.fieldPath = fieldPath;\n  }\n\n  update(args: unknown): void {\n    if (this.disposed) return;\n\n    try {\n      const value = getField(args as T, this.fieldPath);\n\n      if (value !== undefined) {\n        this.controller.enqueue(value);\n      }\n\n      // Check if the field is complete, if so close the stream\n      if (\n        getPartialJsonObjectFieldState(\n          args as Record<string, unknown>,\n          this.fieldPath,\n        ) === \"complete\"\n      ) {\n        this.controller.close();\n        this.dispose();\n      }\n    } catch (e) {\n      this.controller.error(e);\n      this.dispose();\n    }\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n}\n\nclass StreamTextHandle<T> implements Handle {\n  private controller: ReadableStreamDefaultController<unknown>;\n  private disposed = false;\n  private fieldPath: (string | number)[];\n  private lastValue: string | undefined = undefined;\n\n  constructor(\n    controller: ReadableStreamDefaultController<unknown>,\n    fieldPath: (string | number)[],\n  ) {\n    this.controller = controller;\n    this.fieldPath = fieldPath;\n  }\n\n  update(args: unknown): void {\n    if (this.disposed) return;\n\n    try {\n      const value = getField(args as T, this.fieldPath);\n\n      if (value !== undefined && typeof value === \"string\") {\n        const delta = value.substring(this.lastValue?.length || 0);\n        this.lastValue = value;\n        this.controller.enqueue(delta);\n      }\n\n      // Check if the field is complete, if so close the stream\n      if (\n        getPartialJsonObjectFieldState(\n          args as Record<string, unknown>,\n          this.fieldPath,\n        ) === \"complete\"\n      ) {\n        this.controller.close();\n        this.dispose();\n      }\n    } catch (e) {\n      this.controller.error(e);\n      this.dispose();\n    }\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n}\n\nclass ForEachHandle<T> implements Handle {\n  private controller: ReadableStreamDefaultController<unknown>;\n  private disposed = false;\n  private fieldPath: (string | number)[];\n  private processedIndexes = new Set<number>();\n\n  constructor(\n    controller: ReadableStreamDefaultController<unknown>,\n    fieldPath: (string | number)[],\n  ) {\n    this.controller = controller;\n    this.fieldPath = fieldPath;\n  }\n\n  update(args: unknown): void {\n    if (this.disposed) return;\n\n    try {\n      const array = getField(args as T, this.fieldPath);\n\n      if (!Array.isArray(array)) {\n        return;\n      }\n\n      // Check each array element and emit completed ones that haven't been processed\n      for (let i = 0; i < array.length; i++) {\n        if (!this.processedIndexes.has(i)) {\n          const elementPath = [...this.fieldPath, i];\n          if (\n            getPartialJsonObjectFieldState(\n              args as Record<string, unknown>,\n              elementPath,\n            ) === \"complete\"\n          ) {\n            this.controller.enqueue(array[i]);\n            this.processedIndexes.add(i);\n          }\n        }\n      }\n\n      // Check if the entire array is complete\n      if (\n        getPartialJsonObjectFieldState(\n          args as Record<string, unknown>,\n          this.fieldPath,\n        ) === \"complete\"\n      ) {\n        this.controller.close();\n        this.dispose();\n      }\n    } catch (e) {\n      this.controller.error(e);\n      this.dispose();\n    }\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n}\n\n// Implementation of ToolCallReader that uses stream of partial JSON\nexport class ToolCallArgsReaderImpl<T extends ReadonlyJSONObject>\n  implements ToolCallArgsReader<T>\n{\n  private argTextDeltas: ReadableStream<string>;\n  private handles: Set<Handle> = new Set();\n  private args: unknown = parsePartialJsonObject(\"\");\n\n  constructor(argTextDeltas: ReadableStream<string>) {\n    this.argTextDeltas = argTextDeltas;\n    this.processStream();\n  }\n\n  private async processStream(): Promise<void> {\n    try {\n      let accumulatedText = \"\";\n      const reader = this.argTextDeltas.getReader();\n\n      while (true) {\n        const { value, done } = await reader.read();\n        if (done) break;\n\n        accumulatedText += value;\n        const parsedArgs = parsePartialJsonObject(accumulatedText);\n\n        if (parsedArgs !== undefined) {\n          this.args = parsedArgs;\n          // Notify all handles of the updated args\n          for (const handle of this.handles) {\n            handle.update(parsedArgs);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error processing argument stream:\", error);\n      // Notify handles of the error\n      for (const handle of this.handles) {\n        handle.dispose();\n      }\n    }\n  }\n\n  get<PathT extends TypePath<T>>(\n    ...fieldPath: PathT\n  ): Promise<TypeAtPath<T, PathT>> {\n    return new Promise<TypeAtPath<T, PathT>>((resolve, reject) => {\n      const handle = new GetHandle<T, TypeAtPath<T, PathT>>(\n        resolve,\n        reject,\n        fieldPath,\n      );\n\n      // Check if the field is already complete in current args\n      if (\n        this.args &&\n        getPartialJsonObjectFieldState(\n          this.args as Record<string, unknown>,\n          fieldPath,\n        ) === \"complete\"\n      ) {\n        const value = getField(this.args as T, fieldPath);\n        if (value !== undefined) {\n          resolve(value as TypeAtPath<T, PathT>);\n          return;\n        }\n      }\n\n      this.handles.add(handle);\n      handle.update(this.args);\n    });\n  }\n\n  streamValues<PathT extends TypePath<T>>(\n    ...fieldPath: PathT\n  ): AsyncIterableStream<DeepPartial<TypeAtPath<T, PathT>>> {\n    // Use a type assertion to convert the complex TypePath to a simple array\n    const simplePath = fieldPath as unknown as (string | number)[];\n\n    const stream = new ReadableStream<DeepPartial<TypeAtPath<T, PathT>>>({\n      start: (controller) => {\n        const handle = new StreamValuesHandle<T>(controller, simplePath);\n        this.handles.add(handle);\n\n        // Check current args immediately\n        handle.update(this.args);\n      },\n      cancel: () => {\n        // Find and dispose the corresponding handle\n        for (const handle of this.handles) {\n          if (handle instanceof StreamValuesHandle) {\n            handle.dispose();\n            this.handles.delete(handle);\n            break;\n          }\n        }\n      },\n    });\n\n    return asAsyncIterableStream(stream) as any;\n  }\n\n  streamText<PathT extends TypePath<T>>(\n    ...fieldPath: PathT\n  ): TypeAtPath<T, PathT> extends string & infer U\n    ? AsyncIterableStream<U>\n    : never {\n    // Use a type assertion to convert the complex TypePath to a simple array\n    const simplePath = fieldPath as unknown as (string | number)[];\n\n    const stream = new ReadableStream<unknown>({\n      start: (controller) => {\n        const handle = new StreamTextHandle<T>(controller, simplePath);\n        this.handles.add(handle);\n\n        // Check current args immediately\n        handle.update(this.args);\n      },\n      cancel: () => {\n        // Find and dispose the corresponding handle\n        for (const handle of this.handles) {\n          if (handle instanceof StreamTextHandle) {\n            handle.dispose();\n            this.handles.delete(handle);\n            break;\n          }\n        }\n      },\n    });\n\n    return asAsyncIterableStream(stream) as any;\n  }\n\n  forEach<PathT extends TypePath<T>>(\n    ...fieldPath: PathT\n  ): TypeAtPath<T, PathT> extends Array<infer U>\n    ? AsyncIterableStream<U>\n    : never {\n    // Use a type assertion to convert the complex TypePath to a simple array\n    const simplePath = fieldPath as unknown as (string | number)[];\n\n    const stream = new ReadableStream<unknown>({\n      start: (controller) => {\n        const handle = new ForEachHandle<T>(controller, simplePath);\n        this.handles.add(handle);\n\n        // Check current args immediately\n        handle.update(this.args);\n      },\n      cancel: () => {\n        // Find and dispose the corresponding handle\n        for (const handle of this.handles) {\n          if (handle instanceof ForEachHandle) {\n            handle.dispose();\n            this.handles.delete(handle);\n            break;\n          }\n        }\n      },\n    });\n\n    return asAsyncIterableStream(stream) as any;\n  }\n}\n\nexport class ToolCallResponseReaderImpl<TResult extends ReadonlyJSONValue>\n  implements ToolCallResponseReader<TResult>\n{\n  constructor(private readonly promise: Promise<ToolResponse<TResult>>) {}\n\n  public get() {\n    return this.promise;\n  }\n}\n\nexport class ToolCallReaderImpl<\n  TArgs extends ReadonlyJSONObject,\n  TResult extends ReadonlyJSONValue,\n> implements ToolCallReader<TArgs, TResult>\n{\n  public readonly args: ToolCallArgsReaderImpl<TArgs>;\n  public readonly response: ToolCallResponseReaderImpl<TResult>;\n  private readonly writable: WritableStream<string>;\n  private readonly resolve: (value: ToolResponse<TResult>) => void;\n\n  public argsText: string = \"\";\n\n  constructor() {\n    const stream = new TransformStream<string, string>();\n    this.writable = stream.writable;\n    this.args = new ToolCallArgsReaderImpl<TArgs>(stream.readable);\n\n    const { promise, resolve } = promiseWithResolvers<ToolResponse<TResult>>();\n    this.resolve = resolve;\n    this.response = new ToolCallResponseReaderImpl<TResult>(promise);\n  }\n\n  async appendArgsTextDelta(text: string): Promise<void> {\n    const writer = this.writable.getWriter();\n    try {\n      await writer.write(text);\n    } catch (err) {\n      console.warn(err);\n    } finally {\n      writer.releaseLock();\n    }\n\n    this.argsText += text;\n  }\n\n  setResponse(value: ToolResponse<TResult>): void {\n    this.resolve(value);\n  }\n\n  result = {\n    get: async () => {\n      const response = await this.response.get();\n      return response.result;\n    },\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2525, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/tool/ToolExecutionStream.ts"],"sourcesContent":["import sjson from \"secure-json-parse\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport {\n  AssistantMetaStreamChunk,\n  AssistantMetaTransformStream,\n} from \"../utils/stream/AssistantMetaTransformStream\";\nimport { PipeableTransformStream } from \"../utils/stream/PipeableTransformStream\";\nimport {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from \"../../utils/json/json-value\";\nimport { ToolResponse } from \"./ToolResponse\";\nimport { withPromiseOrValue } from \"../utils/withPromiseOrValue\";\nimport { ToolCallReaderImpl } from \"./ToolCallReader\";\nimport { ToolCallReader } from \"./tool-types\";\n\ntype ToolCallback = (toolCall: {\n  toolCallId: string;\n  toolName: string;\n  args: ReadonlyJSONObject;\n}) =>\n  | Promise<ToolResponse<ReadonlyJSONValue>>\n  | ToolResponse<ReadonlyJSONValue>\n  | undefined;\n\ntype ToolStreamCallback = <\n  TArgs extends ReadonlyJSONObject = ReadonlyJSONObject,\n  TResult extends ReadonlyJSONValue = ReadonlyJSONValue,\n>(toolCall: {\n  reader: ToolCallReader<TArgs, TResult>;\n  toolCallId: string;\n  toolName: string;\n}) => void;\n\ntype ToolExecutionOptions = {\n  execute: ToolCallback;\n  streamCall: ToolStreamCallback;\n};\n\nexport class ToolExecutionStream extends PipeableTransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(options: ToolExecutionOptions) {\n    const toolCallPromises = new Map<string, PromiseLike<void>>();\n    const toolCallControllers = new Map<\n      string,\n      ToolCallReaderImpl<ReadonlyJSONObject, ReadonlyJSONValue>\n    >();\n\n    super((readable) => {\n      const transform = new TransformStream<\n        AssistantMetaStreamChunk,\n        AssistantStreamChunk\n      >({\n        transform(chunk, controller) {\n          // forward everything\n          if (chunk.type !== \"part-finish\" || chunk.meta.type !== \"tool-call\") {\n            controller.enqueue(chunk);\n          }\n\n          const type = chunk.type;\n\n          switch (type) {\n            case \"part-start\":\n              if (chunk.part.type === \"tool-call\") {\n                const reader = new ToolCallReaderImpl<\n                  ReadonlyJSONObject,\n                  ReadonlyJSONValue\n                >();\n                toolCallControllers.set(chunk.part.toolCallId, reader);\n\n                options.streamCall({\n                  reader,\n                  toolCallId: chunk.part.toolCallId,\n                  toolName: chunk.part.toolName,\n                });\n              }\n              break;\n            case \"text-delta\": {\n              if (chunk.meta.type === \"tool-call\") {\n                const toolCallId = chunk.meta.toolCallId;\n\n                const controller = toolCallControllers.get(toolCallId);\n                if (!controller)\n                  throw new Error(\"No controller found for tool call\");\n                controller.appendArgsTextDelta(chunk.textDelta);\n              }\n              break;\n            }\n            case \"result\": {\n              if (chunk.meta.type !== \"tool-call\") break;\n\n              const { toolCallId } = chunk.meta;\n              const controller = toolCallControllers.get(toolCallId);\n              if (!controller)\n                throw new Error(\"No controller found for tool call\");\n              controller.setResponse(\n                new ToolResponse({\n                  result: chunk.result,\n                  artifact: chunk.artifact,\n                  isError: chunk.isError,\n                }),\n              );\n              break;\n            }\n            case \"tool-call-args-text-finish\": {\n              if (chunk.meta.type !== \"tool-call\") break;\n\n              const { toolCallId, toolName } = chunk.meta;\n              const streamController = toolCallControllers.get(toolCallId)!;\n              if (!streamController)\n                throw new Error(\"No controller found for tool call\");\n\n              const promise = withPromiseOrValue(\n                () => {\n                  if (!streamController.argsText) {\n                    console.log(\n                      \"Encountered tool call without args, this should never happen\",\n                    );\n                    throw new Error(\n                      \"Encountered tool call without args, this is unexpected.\",\n                    );\n                  }\n\n                  let args;\n                  try {\n                    args = sjson.parse(streamController.argsText);\n                  } catch (e) {\n                    throw new Error(\n                      `Function parameter parsing failed. ${JSON.stringify((e as Error).message)}`,\n                    );\n                  }\n\n                  return options.execute({\n                    toolCallId,\n                    toolName,\n                    args,\n                  });\n                },\n                (c) => {\n                  if (c === undefined) return;\n\n                  // TODO how to handle new ToolResult({ result: undefined })?\n                  const result = new ToolResponse({\n                    artifact: c.artifact,\n                    result: c.result,\n                    isError: c.isError,\n                  });\n                  streamController.setResponse(result);\n                  controller.enqueue({\n                    type: \"result\",\n                    path: chunk.path,\n                    ...result,\n                  });\n                },\n                (e) => {\n                  const result = new ToolResponse({\n                    result: String(e),\n                    isError: true,\n                  });\n\n                  streamController.setResponse(result);\n                  controller.enqueue({\n                    type: \"result\",\n                    path: chunk.path,\n                    ...result,\n                  });\n                },\n              );\n              if (promise) {\n                toolCallPromises.set(toolCallId, promise);\n              }\n              break;\n            }\n\n            case \"part-finish\": {\n              if (chunk.meta.type !== \"tool-call\") break;\n\n              const { toolCallId } = chunk.meta;\n              const toolCallPromise = toolCallPromises.get(toolCallId);\n              if (toolCallPromise) {\n                toolCallPromise.then(() => {\n                  toolCallPromises.delete(toolCallId);\n                  toolCallControllers.delete(toolCallId);\n\n                  controller.enqueue(chunk);\n                });\n              } else {\n                controller.enqueue(chunk);\n              }\n            }\n          }\n        },\n        async flush() {\n          await Promise.all(toolCallPromises.values());\n        },\n      });\n\n      return readable\n        .pipeThrough(new AssistantMetaTransformStream())\n        .pipeThrough(transform);\n    });\n  }\n}\n"],"names":["controller"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2672, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/tool/toolResultStream.ts"],"sourcesContent":["import { Tool, ToolCallReader, ToolExecuteFunction } from \"./tool-types\";\nimport { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport { ToolResponse } from \"./ToolResponse\";\nimport { ToolExecutionStream } from \"./ToolExecutionStream\";\nimport { AssistantMessage } from \"../utils/types\";\nimport { ReadonlyJSONObject, ReadonlyJSONValue } from \"../../utils\";\n\nconst isStandardSchemaV1 = (\n  schema: unknown,\n): schema is StandardSchemaV1<unknown> => {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    \"~standard\" in schema &&\n    (schema as StandardSchemaV1<unknown>)[\"~standard\"].version === 1\n  );\n};\n\nfunction getToolResponse(\n  tools: Record<string, Tool> | undefined,\n  abortSignal: AbortSignal,\n  toolCall: {\n    toolCallId: string;\n    toolName: string;\n    args: ReadonlyJSONObject;\n  },\n) {\n  const tool = tools?.[toolCall.toolName];\n  if (!tool || !tool.execute) return undefined;\n\n  const getResult = async (\n    toolExecute: ToolExecuteFunction<ReadonlyJSONObject, unknown>,\n  ): Promise<ToolResponse<ReadonlyJSONValue>> => {\n    let executeFn = toolExecute;\n\n    if (isStandardSchemaV1(tool.parameters)) {\n      let result = tool.parameters[\"~standard\"].validate(toolCall.args);\n      if (result instanceof Promise) result = await result;\n\n      if (result.issues) {\n        executeFn =\n          tool.experimental_onSchemaValidationError ??\n          (() => {\n            throw new Error(\n              `Function parameter validation failed. ${JSON.stringify(result.issues)}`,\n            );\n          });\n      }\n    }\n\n    const result = (await executeFn(toolCall.args, {\n      toolCallId: toolCall.toolCallId,\n      abortSignal,\n    })) as unknown as ReadonlyJSONValue;\n    return ToolResponse.toResponse(result);\n  };\n\n  return getResult(tool.execute);\n}\n\nfunction getToolStreamResponse(\n  tools: Record<string, Tool> | undefined,\n  abortSignal: AbortSignal,\n  reader: ToolCallReader<any, ReadonlyJSONValue>,\n  context: {\n    toolCallId: string;\n    toolName: string;\n  },\n) {\n  tools?.[context.toolName]?.streamCall?.(reader, {\n    toolCallId: context.toolCallId,\n    abortSignal,\n  });\n}\n\nexport async function unstable_runPendingTools(\n  message: AssistantMessage,\n  tools: Record<string, Tool> | undefined,\n  abortSignal: AbortSignal,\n) {\n  // TODO parallel tool calling\n  for (const part of message.parts) {\n    if (part.type === \"tool-call\") {\n      const promiseOrUndefined = getToolResponse(tools, abortSignal, part);\n      if (promiseOrUndefined) {\n        const result = await promiseOrUndefined;\n        const updatedParts = message.parts.map((p) => {\n          if (p.type === \"tool-call\" && p.toolCallId === part.toolCallId) {\n            return {\n              ...p,\n              state: \"result\" as const,\n              ...(result.artifact !== undefined\n                ? { artifact: result.artifact }\n                : {}),\n              result: result.result as ReadonlyJSONValue,\n              isError: result.isError,\n            };\n          }\n          return p;\n        });\n        message = {\n          ...message,\n          parts: updatedParts,\n          content: updatedParts,\n        };\n      }\n    }\n  }\n  return message;\n}\n\nexport function toolResultStream(\n  tools: Record<string, Tool> | undefined,\n  abortSignal: AbortSignal,\n) {\n  return new ToolExecutionStream({\n    execute: (toolCall) => getToolResponse(tools, abortSignal, toolCall),\n    streamCall: ({ reader, ...context }) =>\n      getToolStreamResponse(tools, abortSignal, reader, context),\n  });\n}\n"],"names":["result"],"mappings":";;;;;AAEA,SAAS,oBAAoB;AAC7B,SAAS,2BAA2B;;;AAIpC,IAAM,qBAAqB,CACzB,WACwC;IACxC,OACE,OAAO,WAAW,YAClB,WAAW,QACX,eAAe,UACd,MAAA,CAAqC,WAAW,CAAA,CAAE,OAAA,KAAY;AAEnE;AAEA,SAAS,gBACP,KAAA,EACA,WAAA,EACA,QAAA,EAKA;IACA,MAAM,OAAO,OAAA,CAAQ,SAAS,QAAQ,CAAA;IACtC,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAA,CAAS,CAAA,OAAO,KAAA;IAEnC,MAAM,YAAY,OAChB,gBAC6C;QAC7C,IAAI,YAAY;QAEhB,IAAI,mBAAmB,KAAK,UAAU,GAAG;YACvC,IAAIA,UAAS,KAAK,UAAA,CAAW,WAAW,CAAA,CAAE,QAAA,CAAS,SAAS,IAAI;YAChE,IAAIA,mBAAkB,QAAS,CAAAA,UAAS,MAAMA;YAE9C,IAAIA,QAAO,MAAA,EAAQ;gBACjB,YACE,KAAK,oCAAA,IAAA,CACJ,MAAM;oBACL,MAAM,IAAI,MACR,CAAA,sCAAA,EAAyC,KAAK,SAAA,CAAUA,QAAO,MAAM,CAAC,EAAA;gBAE1E,CAAA;YACJ;QACF;QAEA,MAAM,SAAU,MAAM,UAAU,SAAS,IAAA,EAAM;YAC7C,YAAY,SAAS,UAAA;YACrB;QACF,CAAC;QACD,mLAAO,eAAA,CAAa,UAAA,CAAW,MAAM;IACvC;IAEA,OAAO,UAAU,KAAK,OAAO;AAC/B;AAEA,SAAS,sBACP,KAAA,EACA,WAAA,EACA,MAAA,EACA,OAAA,EAIA;IACA,OAAA,CAAQ,QAAQ,QAAQ,CAAA,EAAG,aAAa,QAAQ;QAC9C,YAAY,QAAQ,UAAA;QACpB;IACF,CAAC;AACH;AAEA,eAAsB,yBACpB,OAAA,EACA,KAAA,EACA,WAAA,EACA;IAEA,KAAA,MAAW,QAAQ,QAAQ,KAAA,CAAO;QAChC,IAAI,KAAK,IAAA,KAAS,aAAa;YAC7B,MAAM,qBAAqB,gBAAgB,OAAO,aAAa,IAAI;YACnE,IAAI,oBAAoB;gBACtB,MAAM,SAAS,MAAM;gBACrB,MAAM,eAAe,QAAQ,KAAA,CAAM,GAAA,CAAI,CAAC,MAAM;oBAC5C,IAAI,EAAE,IAAA,KAAS,eAAe,EAAE,UAAA,KAAe,KAAK,UAAA,EAAY;wBAC9D,OAAO;4BACL,GAAG,CAAA;4BACH,OAAO;4BACP,GAAI,OAAO,QAAA,KAAa,KAAA,IACpB;gCAAE,UAAU,OAAO,QAAA;4BAAS,IAC5B,CAAC,CAAA;4BACL,QAAQ,OAAO,MAAA;4BACf,SAAS,OAAO,OAAA;wBAClB;oBACF;oBACA,OAAO;gBACT,CAAC;gBACD,UAAU;oBACR,GAAG,OAAA;oBACH,OAAO;oBACP,SAAS;gBACX;YACF;QACF;IACF;IACA,OAAO;AACT;AAEO,SAAS,iBACd,KAAA,EACA,WAAA,EACA;IACA,OAAO,uLAAI,sBAAA,CAAoB;QAC7B,SAAS,CAAC,WAAa,gBAAgB,OAAO,aAAa,QAAQ;QACnE,YAAY,CAAC,EAAE,MAAA,EAAQ,GAAG,QAAQ,CAAA,GAChC,sBAAsB,OAAO,aAAa,QAAQ,OAAO;IAC7D,CAAC;AACH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2766, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/accumulators/AssistantMessageStream.ts"],"sourcesContent":["import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantMessage } from \"../utils/types\";\nimport { AssistantMessageAccumulator } from \"./assistant-message-accumulator\";\n\nexport class AssistantMessageStream {\n  constructor(public readonly readable: ReadableStream<AssistantMessage>) {\n    this.readable = readable;\n  }\n\n  static fromAssistantStream(stream: AssistantStream) {\n    return new AssistantMessageStream(\n      stream.pipeThrough(new AssistantMessageAccumulator()),\n    );\n  }\n\n  async unstable_result(): Promise<AssistantMessage> {\n    let last: AssistantMessage | undefined;\n    for await (const chunk of this) {\n      last = chunk;\n    }\n\n    if (!last) {\n      return {\n        role: \"assistant\",\n        status: { type: \"complete\", reason: \"unknown\" },\n        parts: [],\n        content: [],\n        metadata: {\n          unstable_state: null,\n          unstable_data: [],\n          unstable_annotations: [],\n          steps: [],\n          custom: {},\n        },\n      };\n    }\n    return last;\n  }\n\n  [Symbol.asyncIterator]() {\n    const reader = this.readable.getReader();\n    return {\n      async next(): Promise<IteratorResult<AssistantMessage, undefined>> {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: undefined } : { done: false, value };\n      },\n    };\n  }\n\n  tee(): [AssistantMessageStream, AssistantMessageStream] {\n    const [readable1, readable2] = this.readable.tee();\n    return [\n      new AssistantMessageStream(readable1),\n      new AssistantMessageStream(readable2),\n    ];\n  }\n}\n"],"names":[],"mappings":";;;;AAEA,SAAS,mCAAmC;;AAErC,IAAM,yBAAN,MAAM,wBAAuB;IAClC,YAA4B,QAAA,CAA4C;QAA5C,IAAA,CAAA,QAAA,GAAA;QAC1B,IAAA,CAAK,QAAA,GAAW;IAClB;IAEA,OAAO,oBAAoB,MAAA,EAAyB;QAClD,OAAO,IAAI,wBACT,OAAO,WAAA,CAAY,+MAAI,8BAAA,CAA4B,CAAC;IAExD;IAEA,MAAM,kBAA6C;QACjD,IAAI;QACJ,WAAA,MAAiB,SAAS,IAAA,CAAM;YAC9B,OAAO;QACT;QAEA,IAAI,CAAC,MAAM;YACT,OAAO;gBACL,MAAM;gBACN,QAAQ;oBAAE,MAAM;oBAAY,QAAQ;gBAAU;gBAC9C,OAAO,CAAC,CAAA;gBACR,SAAS,CAAC,CAAA;gBACV,UAAU;oBACR,gBAAgB;oBAChB,eAAe,CAAC,CAAA;oBAChB,sBAAsB,CAAC,CAAA;oBACvB,OAAO,CAAC,CAAA;oBACR,QAAQ,CAAC;gBACX;YACF;QACF;QACA,OAAO;IACT;IAEA,CAAC,OAAO,aAAa,CAAA,GAAI;QACvB,MAAM,SAAS,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU;QACvC,OAAO;YACL,MAAM,OAA6D;gBACjE,MAAM,EAAE,IAAA,EAAM,KAAA,CAAM,CAAA,GAAI,MAAM,OAAO,IAAA,CAAK;gBAC1C,OAAO,OAAO;oBAAE,MAAM;oBAAM,OAAO,KAAA;gBAAU,IAAI;oBAAE,MAAM;oBAAO;gBAAM;YACxE;QACF;IACF;IAEA,MAAwD;QACtD,MAAM,CAAC,WAAW,SAAS,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI;QACjD,OAAO;YACL,IAAI,wBAAuB,SAAS;YACpC,IAAI,wBAAuB,SAAS;SACtC;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2836, "column": 0}, "map": {"version":3,"sources":["file:///Users/vanshikayadav/Documents/Generative%20AI/my-app/node_modules/assistant-stream/src/core/serialization/PlainText.ts"],"sourcesContent":["import { AssistantStreamEncoder } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { AssistantTransformStream } from \"../utils/stream/AssistantTransformStream\";\nimport { PipeableTransformStream } from \"../utils/stream/PipeableTransformStream\";\n\nexport class PlainTextEncoder\n  extends PipeableTransformStream<AssistantStreamChunk, Uint8Array>\n  implements AssistantStreamEncoder\n{\n  headers = new Headers({\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    \"x-vercel-ai-data-stream\": \"v1\",\n  });\n\n  constructor() {\n    super((readable) => {\n      const transform = new TransformStream<AssistantStreamChunk, string>({\n        transform(chunk, controller) {\n          const type = chunk.type;\n          switch (type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n\n            case \"part-start\":\n            case \"part-finish\":\n            case \"step-start\":\n            case \"step-finish\":\n            case \"message-finish\":\n            case \"error\":\n              break;\n\n            default:\n              const unsupportedType:\n                | \"tool-call-args-text-finish\"\n                | \"data\"\n                | \"annotations\"\n                | \"tool-call-begin\"\n                | \"tool-call-delta\"\n                | \"result\"\n                | \"update-state\" = type;\n              throw new Error(`unsupported chunk type: ${unsupportedType}`);\n          }\n        },\n      });\n\n      return readable\n        .pipeThrough(transform)\n        .pipeThrough(new TextEncoderStream());\n    });\n  }\n}\n\nexport class PlainTextDecoder extends PipeableTransformStream<\n  Uint8Array,\n  AssistantStreamChunk\n> {\n  constructor() {\n    super((readable) => {\n      const transform = new AssistantTransformStream<string>({\n        transform(chunk, controller) {\n          controller.appendText(chunk);\n        },\n      });\n\n      return readable\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(transform);\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;AAEA,SAAS,gCAAgC;AACzC,SAAS,+BAA+B;;;AAEjC,IAAM,mBAAN,gNACG,0BAAA,CAEV;IACE,UAAU,IAAI,QAAQ;QACpB,gBAAgB;QAChB,2BAA2B;IAC7B,CAAC,EAAA;IAED,aAAc;QACZ,KAAA,CAAM,CAAC,aAAa;YAClB,MAAM,YAAY,IAAI,gBAA8C;gBAClE,WAAU,KAAA,EAAO,UAAA,EAAY;oBAC3B,MAAM,OAAO,MAAM,IAAA;oBACnB,OAAQ,MAAM;wBACZ,KAAK;4BACH,WAAW,OAAA,CAAQ,MAAM,SAAS;4BAClC;wBAEF,KAAK;wBACL,KAAK;wBACL,KAAK;wBACL,KAAK;wBACL,KAAK;wBACL,KAAK;4BACH;wBAEF;4BACE,MAAM,kBAOe;4BACrB,MAAM,IAAI,MAAM,CAAA,wBAAA,EAA2B,eAAe,EAAE;oBAChE;gBACF;YACF,CAAC;YAED,OAAO,SACJ,WAAA,CAAY,SAAS,EACrB,WAAA,CAAY,IAAI,kBAAkB,CAAC;QACxC,CAAC;IACH;AACF;AAEO,IAAM,mBAAN,gNAA+B,0BAAA,CAGpC;IACA,aAAc;QACZ,KAAA,CAAM,CAAC,aAAa;YAClB,MAAM,YAAY,uMAAI,2BAAA,CAAiC;gBACrD,WAAU,KAAA,EAAO,UAAA,EAAY;oBAC3B,WAAW,UAAA,CAAW,KAAK;gBAC7B;YACF,CAAC;YAED,OAAO,SACJ,WAAA,CAAY,IAAI,kBAAkB,CAAC,EACnC,WAAA,CAAY,SAAS;QAC1B,CAAC;IACH;AACF","ignoreList":[0],"debugId":null}}]
}